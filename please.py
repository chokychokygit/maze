"""
Enhanced Robot Exploration with Integrated Marker Detection

This file combines the best exploration logic from best_code.py with marker detection
capabilities from marker_red_part.py. Key features:

üéØ MARKER DETECTION INTEGRATION:
- Automatic marker scanning after each gimbal ToF scan (-90¬∞, 0¬∞, 90¬∞)
- Special back direction scanning (180¬∞) for initial node (0,0)
- MarkerVisionHandler for continuous marker detection
- Comprehensive marker tracking per node and direction

üîç SCANNING PATTERN:
- Primary: ToF wall detection + RED color filtering ‚Üí marker scanning only where red detected
- Red detection during ToF scan at 0¬∞, -90¬∞, 90¬∞ (and 180¬∞ for initial node)
- Marker scanning with gimbal tilt (-20¬∞) only in red-detected directions
- Enhanced GraphNode with marker properties (markersFound, markerScanResults, hasMarkers)

üìä REPORTING:
- Marker statistics in exploration reports
- Markers found by direction and node
- Marker detection rate calculations
"""

import time
import robomaster
from robomaster import robot, vision
import numpy as np
from scipy.ndimage import median_filter
from datetime import datetime
import json
from collections import deque
import cv2
import os

ROBOT_FACE = 1 # 0 1
CURRENT_TARGET_YAW = 0.0

# ===== Marker Detection Classes =====
class MarkerInfo:
    def __init__(self, x, y, w, h, marker_id):
        self._x = x
        self._y = y
        self._w = w
        self._h = h
        self._id = marker_id

    @property
    def id(self):
        return self._id

class MarkerVisionHandler:
    def __init__(self):
        self.markers = []
        self.marker_detected = False
        self.is_active = False
        self.detection_timeout = 1.0
    
    def on_detect_marker(self, marker_info):
        if not self.is_active:
            return
            
        if len(marker_info) > 0:
            valid_markers = []
            for i in range(len(marker_info)):
                x, y, w, h, marker_id = marker_info[i]
                marker = MarkerInfo(x, y, w, h, marker_id)
                valid_markers.append(marker)
            
            if valid_markers:
                self.marker_detected = True
                self.markers = valid_markers
    
    def wait_for_markers(self, timeout=None):
        if timeout is None:
            timeout = self.detection_timeout
        
        print(f"‚è±Ô∏è Waiting {timeout} seconds for marker detection...")
        
        self.marker_detected = False
        self.markers.clear()
        
        start_time = time.time()
        
        while (time.time() - start_time) < timeout:
            if self.marker_detected:
                print(f"‚úÖ Marker detected after {time.time() - start_time:.1f}s")
                break
            time.sleep(0.02)
        
        return self.marker_detected
    
    def start_continuous_detection(self, vision):
        try:
            self.stop_continuous_detection(vision)
            time.sleep(0.3)
            
            result = vision.sub_detect_info(name="marker", callback=self.on_detect_marker)
            if result:
                self.is_active = True
                print("‚úÖ Marker detection activated")
                return True
            else:
                print("‚ùå Failed to start marker detection")
                return False
        except Exception as e:
            print(f"‚ùå Error starting marker detection: {e}")
            return False
    
    def stop_continuous_detection(self, vision):
        try:
            self.is_active = False
            vision.unsub_detect_info(name="marker")
        except:
            pass
    
    def reset_detection(self):
        self.marker_detected = False
        self.markers.clear()

# ===== Direction Helper Functions =====
def get_direction_name(angle):
    """‡πÅ‡∏õ‡∏•‡∏á‡∏≠‡∏á‡∏®‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á"""
    direction_map = {
        0: "‡∏´‡∏ô‡πâ‡∏≤ (Front)",
        -90: "‡∏ã‡πâ‡∏≤‡∏¢ (Left)", 
        90: "‡∏Ç‡∏ß‡∏≤ (Right)",
        180: "‡∏´‡∏•‡∏±‡∏á (Back)",
        -180: "‡∏´‡∏•‡∏±‡∏á (Back)"
    }
    return direction_map.get(angle, f"‡∏≠‡∏á‡∏®‡∏≤ {angle}")

def get_compass_direction(angle):
    """‡πÅ‡∏õ‡∏•‡∏á‡∏≠‡∏á‡∏®‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÄ‡∏Ç‡πá‡∏°‡∏ó‡∏¥‡∏®"""
    # ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö gimbal yaw: 0¬∞ = ‡∏´‡∏ô‡πâ‡∏≤, -90¬∞ = ‡∏ã‡πâ‡∏≤‡∏¢, 90¬∞ = ‡∏Ç‡∏ß‡∏≤
    compass_map = {
        0: "‡πÄ‡∏´‡∏ô‡∏∑‡∏≠ (N)",
        -90: "‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏ï‡∏Å (W)",
        90: "‡∏ï‡∏∞‡∏ß‡∏±‡∏ô‡∏≠‡∏≠‡∏Å (E)",
        180: "‡πÉ‡∏ï‡πâ (S)",
        -180: "‡πÉ‡∏ï‡πâ (S)"
    }
    return compass_map.get(angle, f"{angle}¬∞")

# ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏•‡∏≤‡∏™‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß
class MovementTracker:
    def __init__(self):
        self.consecutive_forward_moves = 0
        self.consecutive_backward_moves = 0
        self.movement_history = []  # ‡πÄ‡∏Å‡πá‡∏ö‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß
        self.last_movement_type = None  # 'forward', 'backward', 'rotation'
        
    def record_movement(self, movement_type):
        """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ï‡∏±‡∏ß‡∏ô‡∏±‡∏ö"""
        self.movement_history.append(movement_type)
        
        if movement_type == 'forward':
            if self.last_movement_type == 'forward':
                self.consecutive_forward_moves += 1
            else:
                self.consecutive_forward_moves = 1
            # ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ï‡∏±‡∏ß‡∏ô‡∏±‡∏ö‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á
            self.consecutive_backward_moves = 0
            
        elif movement_type == 'backward':
            if self.last_movement_type == 'backward':
                self.consecutive_backward_moves += 1
            else:
                self.consecutive_backward_moves = 1
            # ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ï‡∏±‡∏ß‡∏ô‡∏±‡∏ö‡πÄ‡∏î‡∏¥‡∏ô‡∏´‡∏ô‡πâ‡∏≤
            self.consecutive_forward_moves = 0
            
        elif movement_type == 'rotation':
            # ‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô‡∏à‡∏∞‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡∏ï‡∏±‡∏ß‡∏ô‡∏±‡∏ö
            self.consecutive_forward_moves = 0
            self.consecutive_backward_moves = 0
        
        self.last_movement_type = movement_type
        
        print(f"üìä Movement recorded: {movement_type}")
        print(f"   üîÑ Consecutive forward: {self.consecutive_forward_moves}")
        print(f"   ‚Ü©Ô∏è Consecutive backward: {self.consecutive_backward_moves}")
    
    def has_consecutive_forward_moves(self, threshold=2):
        """‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏î‡∏¥‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà"""
        return self.consecutive_forward_moves >= threshold
    
    def has_consecutive_backward_moves(self, threshold=2):
        """‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà"""
        return self.consecutive_backward_moves >= threshold
    
    def reset_counters(self):
        """‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ï‡∏±‡∏ß‡∏ô‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î"""
        self.consecutive_forward_moves = 0
        self.consecutive_backward_moves = 0
        self.last_movement_type = None
        print("üîÑ Movement counters reset!")
    
    def get_movement_status(self):
        """‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"""
        return {
            'consecutive_forward': self.consecutive_forward_moves,
            'consecutive_backward': self.consecutive_backward_moves,
            'last_movement': self.last_movement_type,
            'history_length': len(self.movement_history)
        }

class AttitudeHandler:
    def __init__(self):
        self.current_yaw = 0.0
        self.current_pitch = 0.0
        self.current_roll = 0.0
        self.target_yaw = 0.0
        self.yaw_tolerance = 3
        self.is_monitoring = False
        
    def attitude_handler(self, attitude_info):
        if not self.is_monitoring:
            return
            
        yaw, pitch, roll = attitude_info
        self.current_yaw = yaw
        self.current_pitch = pitch
        self.current_roll = roll
        print(f"\rüß≠ Current chassis attitude: yaw={yaw:.1f}¬∞, pitch={pitch:.1f}¬∞, roll={roll:.1f}¬∞", end="", flush=True)
        
    def start_monitoring(self, chassis):
        self.is_monitoring = True
        chassis.sub_attitude(freq=20, callback=self.attitude_handler)
        
    def stop_monitoring(self, chassis):
        self.is_monitoring = False
        try:
            chassis.unsub_attitude()
        except:
            pass
            
    def normalize_angle(self, angle):
        while angle > 180:
            angle -= 360
        while angle < -180:
            angle += 360
        return angle
        
    def is_at_target_yaw(self, target_yaw=0.0):
        if abs(target_yaw) == 180:
            diff_180 = abs(self.normalize_angle(self.current_yaw - 180))
            diff_neg180 = abs(self.normalize_angle(self.current_yaw - (-180)))
            diff = min(diff_180, diff_neg180)
            target_display = f"¬±180"
        else:
            diff = abs(self.normalize_angle(self.current_yaw - target_yaw))
            target_display = f"{target_yaw}"
            
        is_correct = diff <= self.yaw_tolerance
        print(f"\nüéØ Yaw check: current={self.current_yaw:.1f}¬∞, target={target_display}¬∞, diff={diff:.1f}¬∞, correct={is_correct}")
        return is_correct
        
    def correct_yaw_to_target(self, chassis, target_yaw=0.0):
        if self.is_at_target_yaw(target_yaw):
            print(f"‚úÖ Chassis already at correct yaw: {self.current_yaw:.1f}¬∞ (target: {target_yaw}¬∞)")
            return True
            
        gimbal_to_target = target_yaw - self.current_yaw
        gimbal_diff = self.normalize_angle(gimbal_to_target)
        robot_rotation = -gimbal_diff
        
        print(f"üîß Correcting chassis yaw: from {self.current_yaw:.1f}¬∞ to {target_yaw}¬∞")
        print(f"üìê Gimbal needs to change: {gimbal_diff:.1f}¬∞")
        print(f"üìê Robot will rotate: {robot_rotation:.1f}¬∞")
        
        try:
            if abs(robot_rotation) > self.yaw_tolerance:
                correction_speed = 60
                
                print(f"üîÑ Rotating robot {robot_rotation:.1f}¬∞")
                chassis.move(x=0, y=0, z=robot_rotation, z_speed=correction_speed).wait_for_completed()
                time.sleep(0.3)
            
            final_check = self.is_at_target_yaw(target_yaw)
            
            if final_check:
                print(f"‚úÖ Successfully corrected chassis yaw to {self.current_yaw:.1f}¬∞")
                return True
            else:
                print(f"‚ö†Ô∏è Chassis yaw correction incomplete: {self.current_yaw:.1f}¬∞ (target: {target_yaw}¬∞)")
                
                remaining_gimbal = target_yaw - self.current_yaw
                remaining_diff = self.normalize_angle(remaining_gimbal)
                remaining_robot = -remaining_diff
                print(f"üìê Remaining gimbal difference: {remaining_diff:.1f}¬∞")
                print(f"üìê Additional robot rotation needed: {remaining_robot:.1f}¬∞")
                
                if abs(remaining_robot) > self.yaw_tolerance and abs(remaining_robot) < 45:
                    print(f"üîß Fine-tuning robot with additional {remaining_robot:.1f}¬∞")
                    chassis.move(x=0, y=0, z=remaining_robot, z_speed=60).wait_for_completed()
                    time.sleep(0.3)
                    return self.is_at_target_yaw(target_yaw)
                else:
                    print(f"‚ö†Ô∏è Remaining rotation too large ({remaining_robot:.1f}¬∞), may need multiple corrections")
                return False
                
        except Exception as e:
            print(f"‚ùå Failed to correct chassis yaw: {e}")
            return False

# ===== PID Controller =====
class PID:
    def __init__(self, Kp, Ki, Kd, setpoint=0):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.setpoint = setpoint
        self.prev_error = 0
        self.integral = 0
        self.integral_max = 1.0

    def compute(self, current, dt):
        error = self.setpoint - current
        self.integral += error * dt
        
        if self.integral > self.integral_max:
            self.integral = self.integral_max
        elif self.integral < -self.integral_max:
            self.integral = -self.integral_max
            
        derivative = (error - self.prev_error) / dt if dt > 0 else 0
        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative
        self.prev_error = error
        return output

# ===== Movement Controller =====
class MovementController:
    def __init__(self, chassis):
        self.chassis = chassis
        self.current_x = 0.0
        self.current_y = 0.0
        self.current_z = 0.0
        
        # PID Parameters
        self.KP = 2.08
        self.KI = 0.25
        self.KD = 10
        self.RAMP_UP_TIME = 0.7
        self.ROTATE_TIME = 2.11  # Right turn
        self.ROTATE_LEFT_TIME = 1.9  # Left turn

        # ‡πÄ‡∏û‡∏¥‡πà‡∏° MovementTracker
        self.movement_tracker = MovementTracker()

        # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏° attitude drift correction
        self.nodes_visited_count = 0  # ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡∏ú‡πà‡∏≤‡∏ô‡πÑ‡∏õ
        self.DRIFT_CORRECTION_INTERVAL = 10  # ‡∏ó‡∏∏‡∏Å 9 ‡πÇ‡∏´‡∏ô‡∏î
        self.DRIFT_CORRECTION_ANGLE = 2  # ‡∏´‡∏°‡∏∏‡∏ô‡πÄ‡∏û‡∏¥‡πà‡∏° 3 ‡∏≠‡∏á‡∏®‡∏≤‡πÑ‡∏õ‡∏ó‡∏≤‡∏á‡∏Ç‡∏ß‡∏≤
        self.total_drift_corrections = 0  # ‡∏ô‡∏±‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç
        
        # *** ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô drift correction ‡∏ã‡πâ‡∏≥ ***
        self.last_correction_at = 0  # ‡πÄ‡∏Å‡πá‡∏ö node count ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏ó‡∏≥ correction

        # Subscribe to position updates
        self.chassis.sub_position(freq=20, callback=self.position_handler)
        time.sleep(0.25)
    
    def position_handler(self, position_info):
        self.current_x = position_info[0]
        self.current_y = position_info[1]
        self.current_z = position_info[2]

    def increment_node_visit_for_backtrack_with_correction(self, attitude_handler):
        """‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏¢‡∏µ‡∏¢‡∏°‡∏ä‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ backtrack ‡πÅ‡∏•‡∏∞ trigger drift correction ‡∏ñ‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤"""
        self.nodes_visited_count += 1
        print(f"üìä Backtrack node visit count: {self.nodes_visited_count}")
        
        # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥ drift correction ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà ‡πÅ‡∏•‡∏∞‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏Ñ‡∏¢‡∏ó‡∏≥‡∏ó‡∏µ‡πà count ‡∏ô‡∏µ‡πâ
        if (self.nodes_visited_count % self.DRIFT_CORRECTION_INTERVAL == 0 and 
            self.nodes_visited_count != self.last_correction_at):
            
            print(f"üîß BACKTRACK DRIFT CORRECTION TRIGGERED!")
            print(f"   üìç After {self.nodes_visited_count} total nodes visited (including backtrack)")
            print(f"   üîÑ Correction #{self.total_drift_corrections + 1}")
            
            # ‡∏ó‡∏≥ drift correction
            success = self.perform_attitude_drift_correction(attitude_handler)
            self.last_correction_at = self.nodes_visited_count  # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ß‡πà‡∏≤‡∏ó‡∏≥ correction ‡πÅ‡∏•‡πâ‡∏ß
            
            if success:
                print(f"‚úÖ Backtrack drift correction completed!")
                return True
            else:
                print(f"‚ö†Ô∏è Backtrack drift correction had issues, but continuing...")
                return False
                
        return False

    def increment_node_visit_main_exploration(self, attitude_handler):
        """‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏¢‡∏µ‡∏¢‡∏°‡∏ä‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö main exploration loop ‡πÅ‡∏•‡∏∞ trigger drift correction ‡∏ñ‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡πÄ‡∏ß‡∏•‡∏≤"""
        self.nodes_visited_count += 1
        print(f"üìä Main exploration node visit count: {self.nodes_visited_count}")
        
        # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏ó‡∏≥ drift correction ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà ‡πÅ‡∏•‡∏∞‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏Ñ‡∏¢‡∏ó‡∏≥‡∏ó‡∏µ‡πà count ‡∏ô‡∏µ‡πâ
        if (self.nodes_visited_count % self.DRIFT_CORRECTION_INTERVAL == 0 and 
            self.nodes_visited_count != self.last_correction_at):
            
            print(f"üîß MAIN EXPLORATION DRIFT CORRECTION TRIGGERED!")
            print(f"   üìç After {self.nodes_visited_count} total nodes visited")
            print(f"   üîÑ Correction #{self.total_drift_corrections + 1}")
            
            # ‡∏ó‡∏≥ drift correction
            success = self.perform_attitude_drift_correction(attitude_handler)
            self.last_correction_at = self.nodes_visited_count  # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ß‡πà‡∏≤‡∏ó‡∏≥ correction ‡πÅ‡∏•‡πâ‡∏ß
            
            if success:
                print(f"‚úÖ Main exploration drift correction completed!")
                return True
            else:
                print(f"‚ö†Ô∏è Main exploration drift correction had issues, but continuing...")
                return False
                
        return False

    def perform_attitude_drift_correction(self, attitude_handler):
        """‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç attitude drift ‡πÇ‡∏î‡∏¢‡∏´‡∏°‡∏∏‡∏ô‡∏Ç‡∏ß‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏≤‡∏°‡∏°‡∏∏‡∏°‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î"""
        global CURRENT_TARGET_YAW
        
        print(f"‚öôÔ∏è === PERFORMING ATTITUDE DRIFT CORRECTION ===")
        print(f"üîß Correcting attitude drift after {self.nodes_visited_count} nodes")
        print(f"üìê Adding {self.DRIFT_CORRECTION_ANGLE}¬∞ clockwise correction")

        # ‡πÉ‡∏ä‡πâ yaw ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡∏ê‡∏≤‡∏ô ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏ö‡∏ß‡∏Å‡∏™‡∏∞‡∏™‡∏°
        current_yaw_before = attitude_handler.current_yaw
        target_after_correction = attitude_handler.normalize_angle(
            current_yaw_before + self.DRIFT_CORRECTION_ANGLE
        )

        # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï CURRENT_TARGET_YAW ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
        CURRENT_TARGET_YAW = target_after_correction

        print(f"üìä Drift correction details:")
        print(f"   üß≠ Current yaw before: {current_yaw_before:.1f}¬∞")
        print(f"   üéØ New target: {target_after_correction:.1f}¬∞")

        try:
            success = attitude_handler.correct_yaw_to_target(self.chassis, target_after_correction)

            if success:
                self.total_drift_corrections += 1
                current_yaw_after = attitude_handler.current_yaw

                print(f"‚úÖ Attitude drift correction completed!")
                print(f"   üß≠ Final yaw: {current_yaw_after:.1f}¬∞")
                print(f"   üìà Total corrections performed: {self.total_drift_corrections}")
                print(f"   üìê Total accumulated correction: {self.total_drift_corrections * self.DRIFT_CORRECTION_ANGLE}¬∞")

                self.movement_tracker.record_movement('rotation')

                # ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô trigger ‡∏ã‡πâ‡∏≥ ‚Äî ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å node ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏õ‡πÅ‡∏•‡πâ‡∏ß
                self.last_correction_at = self.nodes_visited_count

                return True
            else:
                print(f"‚ö†Ô∏è Attitude drift correction may be incomplete!")
                return False

        except Exception as e:
            print(f"‚ùå Error during attitude drift correction: {e}")
            return False

        finally:
            print(f"‚öôÔ∏è === ATTITUDE DRIFT CORRECTION END ===")
            time.sleep(0.3)

    def move_forward_with_pid(self, target_distance, axis, direction=1, allow_yaw_correction=True):
        """Move forward using PID control with movement tracking"""
        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß
        movement_type = 'forward' if direction == 1 else 'backward'
        self.movement_tracker.record_movement(movement_type)
        
        # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ß‡πà‡∏≤‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏ï‡∏¥‡∏î‡∏Å‡∏±‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏Å‡∏£‡∏ì‡∏µ‡∏≠‡∏ô‡∏∏‡∏ç‡∏≤‡∏ï‡πÅ‡∏Å‡πâ yaw)
        if allow_yaw_correction:
            if self.movement_tracker.has_consecutive_forward_moves(2):
                print("‚ö†Ô∏è DETECTED: 2 consecutive forward moves!")
                target_angle = attitude_handler.normalize_angle(CURRENT_TARGET_YAW)
                print(f"üéØ Target yaw: {target_angle}¬∞")
                attitude_handler.correct_yaw_to_target(self.chassis, target_angle)
                
            if self.movement_tracker.has_consecutive_backward_moves(2):
                print("‚ö†Ô∏è DETECTED: 2 consecutive backward moves!")
                target_angle = attitude_handler.normalize_angle(CURRENT_TARGET_YAW)
                print(f"üéØ Target yaw: {target_angle}¬∞")
                attitude_handler.correct_yaw_to_target(self.chassis, target_angle)
        
        pid = PID(Kp=self.KP, Ki=self.KI, Kd=self.KD, setpoint=target_distance)
        
        start_time = time.time()
        last_time = start_time
        target_reached = False
        
        # Ramp-up parameters
        min_speed = 0.1
        max_speed = 1.5
        
        if axis == 'x':
            start_position = self.current_x
        else:
            start_position = self.current_y

        direction_text = "FORWARD" if direction == 1 else "BACKWARD"
        print(f"üöÄ Moving {direction_text} {target_distance}m on {axis}-axis, direction: {direction}")
        
        try:
            while not target_reached:
                now = time.time()
                dt = now - last_time
                last_time = now
                elapsed_time = now - start_time
                
                if axis == 'x':
                    current_position = self.current_x
                else:
                    current_position = self.current_y
                
                relative_position = abs(current_position - start_position)

                # PID calculation
                output = pid.compute(relative_position, dt)
                
                # Ramp-up logic
                if elapsed_time < self.RAMP_UP_TIME:
                    ramp_multiplier = min_speed + (elapsed_time / self.RAMP_UP_TIME) * (1.0 - min_speed)
                else:
                    ramp_multiplier = 1.0
                
                ramped_output = output * ramp_multiplier
                speed = max(min(ramped_output, max_speed), -max_speed)
                
                if axis == 'x':
                    self.chassis.drive_speed(x=speed * direction, y=0, z=0, timeout=1)
                else:
                    self.chassis.drive_speed(x=speed * direction, y=0, z=0, timeout=1)

                # Stop condition
                if abs(relative_position - target_distance) < 0.02:
                    print(f"‚úÖ Target reached! Final position: {current_position:.3f}")
                    self.chassis.drive_speed(x=0, y=0, z=0, timeout=0.1)
                    target_reached = True
                    break
                    
        except KeyboardInterrupt:
            print("Movement interrupted by user.")
    
    def rotate_90_degrees_right(self, attitude_handler=None):
        global CURRENT_TARGET_YAW
        print("üîÑ Rotating 90¬∞ RIGHT...")
        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô
        self.movement_tracker.record_movement('rotation')
        time.sleep(0.2)
        
        CURRENT_TARGET_YAW += 90
        target_angle = attitude_handler.normalize_angle(CURRENT_TARGET_YAW)
        
        print(f"üéØ Target yaw: {target_angle}¬∞")
        success = attitude_handler.correct_yaw_to_target(self.chassis, target_angle)
        
        if success:
            print("‚úÖ Right rotation completed!")
        else:
            print("‚ö†Ô∏è Right rotation may be incomplete")
            
        time.sleep(0.2)

    def rotate_90_degrees_left(self, attitude_handler=None):
        global CURRENT_TARGET_YAW
        print("üîÑ Rotating 90¬∞ LEFT...")
        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô
        self.movement_tracker.record_movement('rotation')
        time.sleep(0.2)
        
        CURRENT_TARGET_YAW -= 90
        target_angle = attitude_handler.normalize_angle(CURRENT_TARGET_YAW)
        
        print(f"üéØ Target yaw: {target_angle}¬∞")
        success = attitude_handler.correct_yaw_to_target(self.chassis, target_angle)
        
        if success:
            print("‚úÖ Left rotation completed!")
        else:
            print("‚ö†Ô∏è Left rotation may be incomplete")
            
        time.sleep(0.2)
    
    def reverse_from_dead_end(self):
        """Reverse robot from dead end position"""
        global ROBOT_FACE
        print("üîô DEAD END DETECTED - Reversing...")
        # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏ñ‡∏≠‡∏¢‡∏´‡∏•‡∏±‡∏á
        self.movement_tracker.record_movement('backward')
        # Determine current axis based on robot face
        axis_test = 'x'
        if ROBOT_FACE % 2 == 0:
            axis_test = 'y'
        elif ROBOT_FACE % 2 == 1:
            axis_test = 'x'
        
        print(f"üîô Reversing 0.6m on {axis_test}-axis")
        
        # Move backward using negative direction
        self.move_forward_with_pid(0.6, axis_test, direction=-1)
        
        print("‚úÖ Reverse from dead end completed!")

    def reverse_to_previous_node(self):
        """NEW: Reverse 0.6m to go back to previous node without rotating"""
        self.movement_tracker.record_movement('backward')

        global ROBOT_FACE
        print("üîô BACKTRACKING - Reversing to previous node...")

        axis_test = 'x'
        if ROBOT_FACE % 2 == 0:
            axis_test = 'y'
        elif ROBOT_FACE % 2 == 1:
            axis_test = 'x'
        
        print(f"üîô Reversing 0.6m on {axis_test}-axis for backtrack")
        
        # ‚ùå ‡∏õ‡∏¥‡∏î yaw correction ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á backtracking
        self.move_forward_with_pid(0.6, axis_test, direction=-1, allow_yaw_correction=False)
        
        print("‚úÖ Reverse backtrack completed!")
    
    def cleanup(self):
        """Clean up position subscription"""
        try:
            self.chassis.unsub_position()
        except:
            pass

    def get_drift_correction_status(self):
        """‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç drift ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"""
        return {
            'nodes_visited': self.nodes_visited_count,
            'next_correction_at': ((self.nodes_visited_count // self.DRIFT_CORRECTION_INTERVAL) + 1) * self.DRIFT_CORRECTION_INTERVAL,
            'nodes_until_correction': self.DRIFT_CORRECTION_INTERVAL - (self.nodes_visited_count % self.DRIFT_CORRECTION_INTERVAL),
            'total_corrections': self.total_drift_corrections,
            'correction_interval': self.DRIFT_CORRECTION_INTERVAL,
            'correction_angle': self.DRIFT_CORRECTION_ANGLE,
            'last_correction_at': self.last_correction_at
        }
    
    def reset_drift_correction(self):
        """‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç drift (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö testing ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà)"""
        self.nodes_visited_count = 0
        self.total_drift_corrections = 0
        print("üîÑ Drift correction system reset!")

    def get_movement_status(self):
        """‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"""
        return self.movement_tracker.get_movement_status()
    
    def reset_movement_tracking(self):
        """‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß"""
        self.movement_tracker.reset_counters()

# ===== Graph Node =====
class GraphNode:
    def __init__(self, node_id, position):
        self.id = node_id
        self.position = position  # (x, y)
        self.outOfBoundsExits = []  # list ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÅ‡∏°‡∏û
        self.outOfBoundsCount = 0   # ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ó‡∏≤‡∏á‡∏≠‡∏≠‡∏Å‡∏ô‡∏≠‡∏Å‡πÅ‡∏°‡∏û

        # Wall detection - NOW STORES ABSOLUTE DIRECTIONS
        self.walls = {
            'north': False,
            'south': False,
            'east': False,
            'west': False
        }

        # Legacy support (will be removed)
        self.wallLeft = False
        self.wallRight = False
        self.wallFront = False
        self.wallBack = False

        # Neighbors (connected nodes)
        self.neighbors = {
            'north': None,
            'south': None,
            'east': None,
            'west': None
        }

        # Exploration state
        self.visited = True
        self.visitCount = 1
        self.exploredDirections = []
        self.unexploredExits = []
        self.isDeadEnd = False

        # NEW: Add flag to track if node has been fully scanned
        self.fullyScanned = False
        self.scanTimestamp = None

        # Additional info
        self.marker = False
        self.lastVisited = datetime.now().isoformat()
        self.sensorReadings = {}
        
        # NEW: Marker detection information
        self.markersFound = {}  # Dictionary: {direction: [marker_ids]}
        self.markerScanResults = {}  # Dictionary: {direction: {'marker_ids': [], 'distance': float, 'timestamp': str}}
        self.hasMarkers = False  # Boolean flag if any markers found in any direction
        
        # IMPORTANT: Store the ABSOLUTE direction robot was facing when first scanned
        self.initialScanDirection = None

# ===== Graph Mapper =====
class GraphMapper:
    def __init__(self, min_x=-3, min_y=-3, max_x=3, max_y=3):
        self.nodes = {}
        self.currentPosition = (0, 0)
        self.currentDirection = 'north'
        self.frontierQueue = []
        self.pathStack = []
        self.visitedNodes = set()
        self.previous_node = None

        # === Border limits ===
        self.min_x = min_x
        self.min_y = min_y
        self.max_x = max_x
        self.max_y = max_y

        # Override methods ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ priority-based exploration
        self.find_next_exploration_direction = self.find_next_exploration_direction_with_priority
        self.update_unexplored_exits_absolute = self.update_unexplored_exits_with_priority

    # 3. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö boundary
    def is_position_within_boundaries(self, position):
        """Check if position is within map boundaries"""
        x, y = position
        return (self.min_x <= x <= self.max_x and 
                self.min_y <= y <= self.max_y)

    def get_boundary_status(self):
        """Get current boundary configuration"""
        return {
            'min_x': self.min_x,
            'max_x': self.max_x,
            'min_y': self.min_y,
            'max_y': self.max_y,
            'width': self.max_x - self.min_x + 1,
            'height': self.max_y - self.min_y + 1,
            'total_cells': (self.max_x - self.min_x + 1) * (self.max_y - self.min_y + 1)
        }

    def get_node_id(self, position):
        return f"{position[0]}_{position[1]}"
    
    def create_node(self, position):
        node_id = self.get_node_id(position)
        if node_id not in self.nodes:
            node = GraphNode(node_id, position)
            # Store the absolute direction robot was facing when node was first created
            node.initialScanDirection = self.currentDirection
            self.nodes[node_id] = node
            self.visitedNodes.add(node_id)
        return self.nodes[node_id]

    def get_current_node(self):
        node_id = self.get_node_id(self.currentPosition)
        return self.nodes.get(node_id)
    
    def update_current_node_walls_absolute(self, left_wall, right_wall, front_wall):
        """NEW: Update walls using ABSOLUTE directions"""
        current_node = self.get_current_node()
        if current_node:
            # Map relative sensor readings to absolute directions
            direction_map = {
                'north': {'front': 'north', 'left': 'west', 'right': 'east'},
                'south': {'front': 'south', 'left': 'east', 'right': 'west'},
                'east': {'front': 'east', 'left': 'north', 'right': 'south'},
                'west': {'front': 'west', 'left': 'south', 'right': 'north'}
            }
            
            current_mapping = direction_map[self.currentDirection]
            
            # Update absolute wall information
            current_node.walls[current_mapping['front']] = front_wall
            current_node.walls[current_mapping['left']] = left_wall
            current_node.walls[current_mapping['right']] = right_wall
            
            # Legacy support - update old format too
            current_node.wallFront = front_wall
            current_node.wallLeft = left_wall
            current_node.wallRight = right_wall
            
            current_node.lastVisited = datetime.now().isoformat()
            
            # NEW: Mark node as fully scanned
            current_node.fullyScanned = True
            current_node.scanTimestamp = datetime.now().isoformat()
            
            self.update_unexplored_exits_absolute(current_node)
            self.build_connections()

    # 1. ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô update_unexplored_exits_absolute
    def update_unexplored_exits_absolute(self, node):
        """Update unexplored exits using ABSOLUTE directions + outer border check"""
        node.unexploredExits = []
        node.outOfBoundsExits = []
        node.outOfBoundsCount = 0

        x, y = node.position

        possible_directions = {
            'north': (x, y + 1),
            'south': (x, y - 1),
            'east':  (x + 1, y),
            'west':  (x - 1, y)
        }

        print(f"üß≠ Updating unexplored exits for {node.id} at {node.position}")
        print(f"üîç Wall status: {node.walls}")
        print(f"üó∫Ô∏è Map boundaries: x[{self.min_x},{self.max_x}], y[{self.min_y},{self.max_y}]")

        for direction, target_pos in possible_directions.items():
            target_x, target_y = target_pos
            target_node_id = self.get_node_id(target_pos)

            # === ‚úÖ ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ outer border ===
            is_outer_boundary = (
                target_x < self.min_x or target_x > self.max_x or
                target_y < self.min_y or target_y > self.max_y
            )

            # ‡πÄ‡∏ä‡πá‡∏Ñ wall / explored / target exist
            is_blocked = node.walls.get(direction, True)
            already_explored = direction in node.exploredDirections
            target_exists = target_node_id in self.nodes
            target_fully_explored = False
            if target_exists:
                target_node = self.nodes[target_node_id]
                target_fully_explored = target_node.fullyScanned

            print(f"   üîç Direction {direction}:")
            print(f"      üöß Blocked: {is_blocked}")
            print(f"      ‚úÖ Already explored: {already_explored}")
            print(f"      üóÉÔ∏è  Target exists: {target_exists}")
            print(f"      üîç Target fully explored: {target_fully_explored}")
            print(f"      üåê Is outer boundary: {is_outer_boundary}")

            should_explore = (
                not is_blocked and
                not already_explored and
                (not target_exists or not target_fully_explored)
            )

            if should_explore:
                if is_outer_boundary:
                    node.outOfBoundsExits.append(direction)
                    node.outOfBoundsCount = len(node.outOfBoundsExits)
                    print(f"      üö´ OUTER BOUNDARY! Added to outOfBoundsExits, NO exploration.")
                else:
                    node.unexploredExits.append(direction)
                    print(f"      ‚úÖ ADDED to unexplored exits!")
            else:
                print(f"      ‚ùå NOT added to unexplored exits")

        print(f"üéØ Final unexplored exits for {node.id}: {node.unexploredExits}")
        print(f"üåê Out-of-bounds exits: {node.outOfBoundsExits} (count: {node.outOfBoundsCount})")

        # Frontier queue update
        has_unexplored = len(node.unexploredExits) > 0
        if has_unexplored and node.id not in self.frontierQueue:
            self.frontierQueue.append(node.id)
            print(f"üöÄ Added {node.id} to frontier queue")
        elif not has_unexplored and node.id in self.frontierQueue:
            self.frontierQueue.remove(node.id)
            print(f"üßπ Removed {node.id} from frontier queue")

        # Dead end detection
        blocked_count = sum(1 for blocked in node.walls.values() if blocked)
        node.isDeadEnd = blocked_count >= 3
        if node.isDeadEnd:
            print(f"üö´ DEAD END CONFIRMED at {node.id} - {blocked_count} walls detected!")
            if node.id in self.frontierQueue:
                self.frontierQueue.remove(node.id)
                print(f"üßπ Removed dead end {node.id} from frontier queue")


    
    def build_connections(self):
        """Build connections between adjacent nodes"""
        for node_id, node in self.nodes.items():
            x, y = node.position
            
            # Check all four directions
            directions = {
                'north': (x, y + 1),
                'south': (x, y - 1),
                'east': (x + 1, y),
                'west': (x - 1, y)
            }
            
            for direction, neighbor_pos in directions.items():
                neighbor_id = self.get_node_id(neighbor_pos)
                if neighbor_id in self.nodes:
                    node.neighbors[direction] = self.nodes[neighbor_id]
    
    def get_next_position_from(self, position, direction):
        """Helper method to calculate next position from given position and direction"""
        x, y = position
        if direction == 'north':
            return (x, y + 1)
        elif direction == 'south':
            return (x, y - 1)
        elif direction == 'east':
            return (x + 1, y)
        elif direction == 'west':
            return (x - 1, y)
        return position
    
    def is_dead_end(self, node=None):
        """Check if current node or given node is a dead end"""
        if node is None:
            node = self.get_current_node()
        
        if not node:
            return False
        
        return node.isDeadEnd
    
    def get_next_position(self, direction):
        """Calculate next position based on current position and ABSOLUTE direction"""
        x, y = self.currentPosition
        if direction == 'north':
            return (x, y + 1)
        elif direction == 'south':
            return (x, y - 1)
        elif direction == 'east':
            return (x + 1, y)
        elif direction == 'west':
            return (x - 1, y)
        return self.currentPosition
    
    def get_previous_position(self, direction):
        """Calculate previous position based on current position and direction robot came from"""
        x, y = self.currentPosition
        if direction == 'north':
            return (x, y - 1)  # came from south
        elif direction == 'south':
            return (x, y + 1)  # came from north
        elif direction == 'east':
            return (x - 1, y)  # came from west
        elif direction == 'west':
            return (x + 1, y)  # came from east
        return self.currentPosition
    
    def can_move_to_direction_absolute(self, target_direction):
        """Check if robot can move to target ABSOLUTE direction"""
        current_node = self.get_current_node()
        if not current_node:
            return False
        
        # Check if target direction has a wall using absolute direction
        is_blocked = current_node.walls.get(target_direction, True)
        return not is_blocked
    
    def rotate_to_absolute_direction(self, target_direction, movement_controller, attitude_handler):
        """NEW: Rotate robot to face target ABSOLUTE direction"""
        global ROBOT_FACE
        global CURRENT_TARGET_YAW
        print(f"üéØ Rotating from {self.currentDirection} to {target_direction}")
        
        if self.currentDirection == target_direction:
            print(f"‚úÖ Already facing {target_direction}")
            return
        
        direction_order = ['north', 'east', 'south', 'west']
        current_idx = direction_order.index(self.currentDirection)
        target_idx = direction_order.index(target_direction)
        
        # Calculate shortest rotation
        diff = (target_idx - current_idx) % 4
        
        if diff == 1:  # Turn right
            movement_controller.rotate_90_degrees_right(attitude_handler)
            ROBOT_FACE += 1
        elif diff == 3:  # Turn left
            movement_controller.rotate_90_degrees_left(attitude_handler)
            ROBOT_FACE += 1
        elif diff == 2:  # Turn around (180¬∞)
            movement_controller.rotate_90_degrees_right(attitude_handler)
            movement_controller.rotate_90_degrees_right(attitude_handler)
            ROBOT_FACE += 2
        
        # Update current direction
        self.currentDirection = target_direction
        print(f"‚úÖ Now facing {self.currentDirection}")

    def handle_dead_end(self, movement_controller):
        """Handle dead end situation by reversing"""
        print(f"üö´ === DEAD END HANDLER ACTIVATED ===")
        current_node = self.get_current_node()

        if current_node:
            print(f"üìç Dead end at position: {current_node.position}")
            print(f"üß± Walls: {current_node.walls}")

        # Use the reverse method
        movement_controller.reverse_from_dead_end()

        # Update position after reversing (move back in opposite direction)
        reverse_direction_map = {
            'north': 'south',
            'south': 'north',
            'east': 'west',
            'west': 'east'
        }

        reverse_direction = reverse_direction_map[self.currentDirection]
        self.currentPosition = self.get_next_position(reverse_direction)

        print(f"üîô Reversed to position: {self.currentPosition}")
        print(f"üß≠ Still facing: {self.currentDirection}")

        return True
    
    # 2. ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÉ‡∏ô‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô move_to_absolute_direction
    def move_to_absolute_direction(self, target_direction, movement_controller, attitude_handler):
        """NEW: Move to target ABSOLUTE direction with proper rotation and border check"""
        global ROBOT_FACE

        current_node = self.get_current_node()
        if not current_node:
            print("‚ùå No current node - cannot move")
            return False

        # === ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö border ‡πÅ‡∏ö‡∏ö double-check ===
        target_pos = self.get_next_position(target_direction)
        target_x, target_y = target_pos
        
        is_outside_map = (
            target_x < self.min_x or target_x > self.max_x or
            target_y < self.min_y or target_y > self.max_y
        )
        
        if is_outside_map:
            print(f"üö´ TARGET POSITION {target_pos} IS OUTSIDE MAP BOUNDARIES!")
            print(f"üó∫Ô∏è Map boundaries: x[{self.min_x},{self.max_x}], y[{self.min_y},{self.max_y}]")
            print(f"üö´ Movement to {target_direction} CANCELLED!")
            return False

        # Prevent movement outside border (original check)
        if target_direction in current_node.outOfBoundsExits:
            print(f"üö´ Target direction {target_direction} is OUT OF BOUNDS! Movement cancelled.")
            return False

        print(f"üéØ Moving to ABSOLUTE direction: {target_direction}")
        
        # Check if movement is possible
        if not self.can_move_to_direction_absolute(target_direction):
            print(f"‚ùå BLOCKED! Cannot move to {target_direction} - wall detected!")
            return False
        
        # First rotate to face the target direction
        self.rotate_to_absolute_direction(target_direction, movement_controller, attitude_handler)

        # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà
        movement_status = movement_controller.get_movement_status()
        print(f"üìä Current movement status: {movement_status}")

        # Determine axis for movement
        axis_test = 'x'
        if ROBOT_FACE % 2 == 0:
            axis_test = 'y'
        elif ROBOT_FACE % 2 == 1:
            axis_test = 'x'
        
        print(f"üöÄ Moving forward on {axis_test}-axis")

        # Move forward (‡∏à‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏õ‡πá‡∏ô 'forward' ‡πÉ‡∏ô MovementTracker)
        movement_controller.move_forward_with_pid(0.6, axis_test, direction=1)
        
        # Update position
        self.currentPosition = self.get_next_position(target_direction)
        
        # Mark this direction as explored from the previous node
        if hasattr(self, 'previous_node') and self.previous_node:
            if target_direction not in self.previous_node.exploredDirections:
                self.previous_node.exploredDirections.append(target_direction)
            
            # Remove from unexplored exits
            if target_direction in self.previous_node.unexploredExits:
                self.previous_node.unexploredExits.remove(target_direction)
                print(f"üîÑ Removed {target_direction} from unexplored exits of {self.previous_node.id}")
        
        print(f"‚úÖ Successfully moved to {self.currentPosition}")
        return True

    def reverse_to_absolute_direction(self, target_direction, movement_controller, attitude_handler):
        """NEW: Reverse to target ABSOLUTE direction for backtracking"""
        global ROBOT_FACE
        print(f"üîô BACKTRACK: Reversing to ABSOLUTE direction: {target_direction}")
        
        # Calculate what direction we need to reverse to
        reverse_direction_map = {
            'north': 'south',
            'south': 'north',
            'east': 'west',
            'west': 'east'
        }
        
        required_facing_direction = reverse_direction_map[target_direction]
        
        # First rotate to face the direction OPPOSITE to where we want to go
        self.rotate_to_absolute_direction(required_facing_direction, movement_controller, attitude_handler)
        
        # Now reverse (which will move us in the target direction)
        movement_controller.reverse_to_previous_node()
        
        # Update position
        self.currentPosition = self.get_next_position(target_direction)
        
        print(f"‚úÖ Successfully reversed to {self.currentPosition}, still facing {self.currentDirection}")
        return True

    def find_next_exploration_direction_with_priority(self):
        """Find next exploration direction with LEFT-first priority, skipping out-of-bounds exits"""
        current_node = self.get_current_node()
        if not current_node:
            return None

        if self.is_dead_end(current_node):
            print(f"üö´ Current node is a dead end - no exploration directions available")
            return None

        print(f"üß≠ Current robot facing: {self.currentDirection}")
        print(f"üîç Available unexplored exits: {current_node.unexploredExits}")
        print(f"üåê Out-of-bounds exits: {current_node.outOfBoundsExits}")

        # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î mapping ‡∏ó‡∏¥‡∏®‡∏™‡∏±‡∏°‡∏û‡∏±‡∏ó‡∏ò‡πå
        direction_map = {
            'north': {'front': 'north', 'left': 'west', 'right': 'east', 'back': 'south'},
            'south': {'front': 'south', 'left': 'east', 'right': 'west', 'back': 'north'},
            'east': {'front': 'east', 'left': 'north', 'right': 'south', 'back': 'west'},
            'west': {'front': 'west', 'left': 'south', 'right': 'north', 'back': 'east'}
        }
        current_mapping = direction_map[self.currentDirection]

        # ‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
        priority_order = ['left', 'front', 'right', 'back']
        print(f"üéØ Checking exploration priority order: {priority_order}")

        for relative_direction in priority_order:
            absolute_direction = current_mapping.get(relative_direction)
            if not absolute_direction:
                continue

            # ‡∏Ç‡πâ‡∏≤‡∏°‡∏ó‡∏¥‡∏®‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ô‡∏≠‡∏Å border
            if absolute_direction in current_node.outOfBoundsExits:
                print(f"üö´ {relative_direction} ({absolute_direction}) is OUT OF BOUNDS! Skipping...")
                continue

            # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ó‡∏¥‡∏®‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô unexplored exits ‡πÅ‡∏•‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏î‡πâ
            if absolute_direction in current_node.unexploredExits:
                if self.can_move_to_direction_absolute(absolute_direction):
                    print(f"‚úÖ Selected direction: {relative_direction} ({absolute_direction})")
                    return absolute_direction
                else:
                    print(f"‚ùå {relative_direction} ({absolute_direction}) is blocked by wall!")
                    current_node.unexploredExits.remove(absolute_direction)

        print(f"‚ùå No valid exploration direction found")
        return None

    def update_unexplored_exits_with_priority(self, node):
        """Update unexplored exits with priority ordering"""
        node.unexploredExits = []
        
        x, y = node.position
        
        # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç LEFT-FIRST
        # ‡πÅ‡∏ï‡πà‡πÄ‡∏Å‡πá‡∏ö‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏™‡∏±‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå
        direction_map = {
            'north': {'front': 'north', 'left': 'west', 'right': 'east', 'back': 'south'},
            'south': {'front': 'south', 'left': 'east', 'right': 'west', 'back': 'north'},
            'east': {'front': 'east', 'left': 'north', 'right': 'south', 'back': 'west'},
            'west': {'front': 'west', 'left': 'south', 'right': 'north', 'back': 'east'}
        }
        
        current_mapping = direction_map[self.currentDirection]
        
        # ‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
        priority_order = ['left', 'front', 'right', 'back']
        
        possible_directions = {
            'north': (x, y + 1),
            'south': (x, y - 1),
            'east': (x + 1, y),
            'west': (x - 1, y)
        }
        
        print(f"üß≠ Updating unexplored exits for {node.id} at {node.position}")
        print(f"üîç Wall status: {node.walls}")
        print(f"ü§ñ Robot facing: {self.currentDirection}")
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏°‡∏•‡∏≥‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏Ç‡πâ‡∏≤ unexploredExits
        for relative_dir in priority_order:
            absolute_dir = current_mapping[relative_dir]
            target_pos = possible_directions[absolute_dir]
            target_node_id = self.get_node_id(target_pos)
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°
            is_blocked = node.walls.get(absolute_dir, True)
            already_explored = absolute_dir in node.exploredDirections
            target_exists = target_node_id in self.nodes
            target_fully_explored = False
            if target_exists:
                target_node = self.nodes[target_node_id]
                target_fully_explored = target_node.fullyScanned
            
            print(f"   üìç {relative_dir} ({absolute_dir}):")
            print(f"      üöß Blocked: {is_blocked}")
            print(f"      ‚úÖ Already explored: {already_explored}")
            print(f"      üèóÔ∏è  Target exists: {target_exists}")
            print(f"      üîç Target fully explored: {target_fully_explored}")
            
            should_explore = (not is_blocked and 
                            not already_explored and 
                            (not target_exists or not target_fully_explored))
            
            if should_explore:
                node.unexploredExits.append(absolute_dir)
                print(f"      ‚úÖ ADDED to unexplored exits! (Priority: {relative_dir})")
            else:
                print(f"      ‚ùå NOT added to unexplored exits")
        
        print(f"üéØ Final unexplored exits (ordered by priority): {node.unexploredExits}")
        
        # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï frontier queue
        has_unexplored = len(node.unexploredExits) > 0
        
        if has_unexplored and node.id not in self.frontierQueue:
            self.frontierQueue.append(node.id)
            print(f"üöÄ Added {node.id} to frontier queue")
        elif not has_unexplored and node.id in self.frontierQueue:
            self.frontierQueue.remove(node.id)
            print(f"üßπ Removed {node.id} from frontier queue")
        
        # Dead end detection
        blocked_count = sum(1 for blocked in node.walls.values() if blocked)
        is_dead_end = blocked_count >= 3 and len(node.unexploredExits) == 0
        node.isDeadEnd = is_dead_end
        
        if is_dead_end:
            print(f"üö´ DEAD END CONFIRMED at {node.id} - {blocked_count} walls detected!")
            if node.id in self.frontierQueue:
                self.frontierQueue.remove(node.id)
                print(f"üßπ Removed dead end {node.id} from frontier queue")

    def find_next_exploration_direction(self):
        """Find the next ABSOLUTE direction to explore"""
        current_node = self.get_current_node()
        if not current_node:
            return None
        
        if self.is_dead_end(current_node):
            print(f"üö´ Current node is a dead end - no exploration directions available")
            return None
        
        # Return first unexplored exit (now using absolute directions)
        if current_node.unexploredExits:
            for unexplored_dir in current_node.unexploredExits:
                if self.can_move_to_direction_absolute(unexplored_dir):
                    return unexplored_dir
        
        return None
    
    def find_path_to_frontier(self, target_node_id):
        """Find shortest path to frontier node using BFS"""
        if target_node_id not in self.nodes:
            return None
        
        # BFS to find shortest path
        queue = deque([(self.currentPosition, [])])
        visited = set()
        visited.add(self.currentPosition)
        
        while queue:
            current_pos, path = queue.popleft()
            current_node_id = self.get_node_id(current_pos)
            
            # Check if we reached the target
            if current_node_id == target_node_id:
                return path
            
            # Explore neighbors
            if current_node_id in self.nodes:
                current_node = self.nodes[current_node_id]
                x, y = current_pos
                
                # Check all four directions
                directions = {
                    'north': (x, y + 1),
                    'south': (x, y - 1), 
                    'east': (x + 1, y),
                    'west': (x - 1, y)
                }
                
                for direction, neighbor_pos in directions.items():
                    neighbor_id = self.get_node_id(neighbor_pos)
                    
                    if (neighbor_pos not in visited and 
                        neighbor_id in self.nodes and
                        self.is_path_clear_absolute(current_pos, neighbor_pos, direction)):
                        
                        visited.add(neighbor_pos)
                        new_path = path + [direction]
                        queue.append((neighbor_pos, new_path))
        
        return None  # No path found
    
    def is_path_clear_absolute(self, from_pos, to_pos, direction):
        """Check if path between two adjacent nodes is clear using absolute directions"""
        from_node_id = self.get_node_id(from_pos)
        to_node_id = self.get_node_id(to_pos)
        
        if from_node_id not in self.nodes or to_node_id not in self.nodes:
            return False
        
        from_node = self.nodes[from_node_id]
        
        # Check if there's a wall blocking the path in absolute direction
        is_blocked = from_node.walls.get(direction, True)
        return not is_blocked
    
    def execute_path_to_frontier_with_reverse(self, path, movement_controller, attitude_handler):
        """NEW: Execute path using reverse movements for backtracking WITH NODE COUNTING"""
        print(f"üó∫Ô∏è Executing REVERSE path to frontier: {path}")
        
        # ‡πÄ‡∏ä‡πá‡∏Ñ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏° backtrack
        movement_status = movement_controller.get_movement_status()
        print(f"üìä Movement status before backtracking: {movement_status}")

        drift_corrections_during_backtrack = 0
        initial_correction_count = movement_controller.total_drift_corrections

        for i, step_direction in enumerate(path):
            print(f"üîç Step {i+1}/{len(path)}: Current position: {self.currentPosition}, moving {step_direction}")
            
            # Use reverse movement for backtracking (more efficient)
            success = self.reverse_to_absolute_direction(step_direction, movement_controller, attitude_handler)
            
            if not success:
                print(f"‚ùå Failed to reverse {step_direction} during backtracking!")
                return False
            
            # *** ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡πÇ‡∏´‡∏ô‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ backtrack ‡πÅ‡∏•‡∏∞‡πÄ‡∏ä‡πá‡∏Ñ drift correction ***
            needs_correction = movement_controller.increment_node_visit_for_backtrack_with_correction(attitude_handler)
            
            # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏¥‡∏î drift correction ‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á backtrack
            if needs_correction:
                drift_corrections_during_backtrack = movement_controller.total_drift_corrections - initial_correction_count
                print(f"‚úÖ Backtrack drift correction #{drift_corrections_during_backtrack} completed during step {i+1}!")
            
            time.sleep(0.2)  # Brief pause between moves
        
        if drift_corrections_during_backtrack > 0:
            print(f"üîß Total drift corrections during this backtrack: {drift_corrections_during_backtrack}")
        
        print(f"‚úÖ Successfully reached frontier at {self.currentPosition}")
        return True
    
    def find_nearest_frontier(self):
        """Find frontier with better validation and prioritization"""
        print("üîç === FINDING NEAREST FRONTIER ===")
        
        if not self.frontierQueue:
            print("üîÑ No frontiers in queue - rebuilding...")
            self.rebuild_frontier_queue()
            
            if not self.frontierQueue:
                print("üéâ No unexplored areas found - exploration complete!")
                return None, None, None
        
        # Validate and prioritize frontiers
        valid_frontiers = []
        
        print(f"üîç Checking {len(self.frontierQueue)} frontier candidates...")
        
        for frontier_id in self.frontierQueue[:]:
            if frontier_id not in self.nodes:
                print(f"‚ùå Removing non-existent frontier {frontier_id}")
                continue
                
            frontier_node = self.nodes[frontier_id]
            
            # Re-validate unexplored exits
            print(f"\nüîç Validating frontier {frontier_id} at {frontier_node.position}:")
            print(f"   üìã Claimed unexplored exits: {frontier_node.unexploredExits}")
            
            # Re-check each unexplored exit
            valid_exits = []
            for exit_direction in frontier_node.unexploredExits[:]:
                target_pos = self.get_next_position_from(frontier_node.position, exit_direction)
                target_node_id = self.get_node_id(target_pos)
                
                # Check if this exit is still valid
                target_exists = target_node_id in self.nodes
                if target_exists:
                    target_node = self.nodes[target_node_id]
                    target_fully_explored = target_node.fullyScanned
                    print(f"      üéØ {exit_direction} -> {target_pos}: exists={target_exists}, fully_explored={target_fully_explored}")
                    
                    # Only consider it unexplored if target doesn't exist or isn't fully explored
                    if not target_fully_explored:
                        valid_exits.append(exit_direction)
                        print(f"         ‚úÖ Still valid for exploration")
                    else:
                        print(f"         ‚ùå Target already fully explored")
                else:
                    valid_exits.append(exit_direction)
                    print(f"      üéØ {exit_direction} -> {target_pos}: NEW AREA - valid for exploration")
            
            # Update the node's unexplored exits with validated list
            frontier_node.unexploredExits = valid_exits
            
            if valid_exits:
                valid_frontiers.append(frontier_id)
                print(f"   ‚úÖ Frontier {frontier_id} is VALID with exits: {valid_exits}")
            else:
                print(f"   ‚ùå Frontier {frontier_id} has NO valid unexplored exits")
        
        # Update frontier queue with only valid frontiers
        self.frontierQueue = valid_frontiers
        
        if not valid_frontiers:
            print("üéâ No valid frontiers remaining - exploration complete!")
            return None, None, None
        
        print(f"\nüéØ Found {len(valid_frontiers)} valid frontiers: {valid_frontiers}")
        
        # Find the nearest valid frontier
        best_frontier = None
        best_direction = None
        shortest_path = None
        min_distance = float('inf')
        
        for frontier_id in valid_frontiers:
            frontier_node = self.nodes[frontier_id]
            
            # Find path to this frontier
            path = self.find_path_to_frontier(frontier_id)
            
            if path is not None:
                distance = len(path)
                print(f"   üìç {frontier_id}: distance={distance}, exits={frontier_node.unexploredExits}")
                
                if distance < min_distance:
                    min_distance = distance
                    best_frontier = frontier_id
                    best_direction = frontier_node.unexploredExits[0]  # Take first unexplored direction
                    shortest_path = path
            else:
                print(f"   ‚ùå {frontier_id}: No path found!")
        
        if best_frontier:
            print(f"\nüèÜ SELECTED: {best_frontier} with direction {best_direction} (distance: {min_distance})")
            print(f"üó∫Ô∏è Path: {shortest_path}")
        else:
            print(f"\n‚ùå No reachable frontiers found!")
        
        return best_frontier, best_direction, shortest_path
    
    def rebuild_frontier_queue(self):
        """Rebuild frontier queue with comprehensive validation"""
        print("üîÑ === REBUILDING FRONTIER QUEUE ===")
        self.frontierQueue = []
        
        for node_id, node in self.nodes.items():
            print(f"\nüîç Checking node {node_id} at {node.position}:")
            
            # Re-validate unexplored exits for this node
            valid_exits = []
            
            if hasattr(node, 'unexploredExits'):
                print(f"   üìã Current unexplored exits: {node.unexploredExits}")
                
                for exit_direction in node.unexploredExits:
                    target_pos = self.get_next_position_from(node.position, exit_direction)
                    target_node_id = self.get_node_id(target_pos)
                    
                    # Validate this exit
                    target_exists = target_node_id in self.nodes
                    if target_exists:
                        target_node = self.nodes[target_node_id]
                        if not target_node.fullyScanned:
                            valid_exits.append(exit_direction)
                            print(f"      ‚úÖ {exit_direction} -> {target_pos}: Target not fully explored")
                        else:
                            print(f"      ‚ùå {exit_direction} -> {target_pos}: Target already fully explored")
                    else:
                        valid_exits.append(exit_direction)
                        print(f"      ‚úÖ {exit_direction} -> {target_pos}: NEW AREA")
            
            # Update node's unexplored exits with validated list
            node.unexploredExits = valid_exits
            
            # Add to frontier queue if it has valid unexplored exits
            if valid_exits:
                self.frontierQueue.append(node_id)
                print(f"   üöÄ ADDED to frontier queue with exits: {valid_exits}")
            else:
                print(f"   ‚ùå No valid unexplored exits - not added to frontier")
        
        print(f"\n‚úÖ Frontier queue rebuilt: {len(self.frontierQueue)} frontiers found")
        print(f"üéØ Active frontiers: {self.frontierQueue}")
    
    def print_graph_summary(self):
        print("\n" + "="*60)
        print("üìä GRAPH MAPPING SUMMARY")
        print("="*60)
        print(f"ü§ñ Current Position: {self.currentPosition}")
        print(f"üß≠ Current Direction: {self.currentDirection}")
        print(f"üó∫Ô∏è  Total Nodes: {len(self.nodes)}")
        print(f"üöÄ Frontier Queue: {len(self.frontierQueue)} nodes")
        print("-"*60)
        
        for node_id, node in self.nodes.items():
            print(f"\nüìç Node: {node.id} at {node.position}")
            print(f"   üîç Fully Scanned: {node.fullyScanned}")
            print(f"   üß± Walls (absolute): {node.walls}")
            print(f"   üîç Unexplored exits: {node.unexploredExits}")
            print(f"   ‚úÖ Explored directions: {node.exploredDirections}")
            print(f"   üéØ Is dead end: {node.isDeadEnd}")
            
            if node.sensorReadings:
                print(f"   üì° Sensor readings:")
                for direction, reading in node.sensorReadings.items():
                    print(f"      {direction}: {reading:.2f}cm")
            
            # NEW: Display marker information
            if hasattr(node, 'markersFound') and node.markersFound:
                print(f"   üéØ Markers found:")
                for direction, marker_ids in node.markersFound.items():
                    print(f"      {direction}: {marker_ids}")
            
            if hasattr(node, 'markerScanResults') and node.markerScanResults:
                print(f"   üìä Marker scan details:")
                for direction, scan_result in node.markerScanResults.items():
                    if scan_result['marker_ids']:
                        print(f"      {direction}: {scan_result['marker_ids']} at {scan_result['distance']:.1f}cm")
        
        print("-"*60)
        if self.frontierQueue:
            print(f"üöÄ Next exploration targets: {self.frontierQueue}")
        else:
            print("üéâ EXPLORATION COMPLETE - No more frontiers!")
        print("="*60)

# ===== ToF Sensor Handler =====
class ToFSensorHandler:
    def __init__(self):
        self.CALIBRATION_SLOPE = 0.0894 
        self.CALIBRATION_Y_INTERCEPT = 3.8409
        self.WINDOW_SIZE = 5
        self.tof_buffer = []
        self.WALL_THRESHOLD = 50.00
        
        self.readings = {
            'front': [],
            'left': [],
            'right': []
        }
        
        self.current_scan_direction = None
        self.collecting_data = False
        
    def calibrate_tof_value(self, raw_tof_mm):
        calibrated_cm = (self.CALIBRATION_SLOPE * raw_tof_mm) + self.CALIBRATION_Y_INTERCEPT
        return calibrated_cm
    
    def apply_median_filter(self, data, window_size):
        if len(data) == 0:
            return 0.0 
        if len(data) < window_size:
            return data[-1] 
        else:
            filtered = median_filter(data[-window_size:], size=window_size)
            return filtered[-1]
    
    def tof_data_handler(self, sub_info):
        if not self.collecting_data or not self.current_scan_direction:
            return
            
        raw_tof_mm = sub_info[0]
        
        if raw_tof_mm <= 0 or raw_tof_mm > 4000:
            return
            
        calibrated_tof_cm = self.calibrate_tof_value(raw_tof_mm)
        self.tof_buffer.append(calibrated_tof_cm)
        filtered_tof_cm = self.apply_median_filter(self.tof_buffer, self.WINDOW_SIZE)
        
        if len(self.tof_buffer) <= 20:
            self.readings[self.current_scan_direction].append({
                'filtered_cm': filtered_tof_cm,
                'timestamp': datetime.now().isoformat()
            })
        
        wall_status = "üß± WALL" if filtered_tof_cm <= self.WALL_THRESHOLD else "üö™ OPEN"
        print(f"[{self.current_scan_direction.upper()}] {filtered_tof_cm:.2f}cm {wall_status}")
    
    def start_scanning(self, direction):
        self.current_scan_direction = direction
        self.tof_buffer.clear()
        if direction not in self.readings:
            self.readings[direction] = []
        else:
            self.readings[direction].clear()
        self.collecting_data = True
        
    def stop_scanning(self, unsub_distance_func):
        self.collecting_data = False
        try:
            unsub_distance_func()
        except:
            pass
    
    def get_average_distance(self, direction):
        if direction not in self.readings or len(self.readings[direction]) == 0:
            return 0.0
        
        filtered_values = [reading['filtered_cm'] for reading in self.readings[direction]]
        
        if len(filtered_values) > 4:
            q1 = np.percentile(filtered_values, 25)
            q3 = np.percentile(filtered_values, 75)
            iqr = q3 - q1
            lower_bound = q1 - 1.5 * iqr
            upper_bound = q3 + 1.5 * iqr
            
            filtered_values = [x for x in filtered_values if lower_bound <= x <= upper_bound]
        
        return np.mean(filtered_values) if filtered_values else 0.0
    
    def is_wall_detected(self, direction):
        avg_distance = self.get_average_distance(direction)
        is_wall = avg_distance <= self.WALL_THRESHOLD and avg_distance > 0
        
        print(f"üîç Wall check [{direction.upper()}]: {avg_distance:.2f}cm -> {'WALL' if is_wall else 'OPEN'}")
        
        return is_wall

# ===== Marker Scanning Helper Function =====
def scan_for_markers_at_direction(gimbal, sensor, angle, direction_name, marker_handler, tof_handler, speed=480):
    """
    ‡∏™‡πÅ‡∏Å‡∏ô‡∏´‡∏≤ marker ‡∏ó‡∏µ‡πà‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡∏°‡∏∏‡∏°‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
    
    Args:
        gimbal: Gimbal object
        sensor: Sensor object for ToF distance measurement
        angle: ‡∏°‡∏∏‡∏° gimbal yaw (0, -90, 90, 180)
        direction_name: ‡∏ä‡∏∑‡πà‡∏≠‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á (front, left, right, back)
        marker_handler: MarkerVisionHandler object
        tof_handler: ToFSensorHandler object
        speed: ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Å‡∏≤‡∏£‡∏´‡∏°‡∏∏‡∏ô gimbal
        
    Returns:
        dict: {'marker_ids': [], 'distance': float, 'direction_name': str, 'angle': int, 'timestamp': str}
    """
    compass_dir = get_compass_direction(angle)
    print(f"üéØ Scanning {direction_name} | Gimbal Yaw: {angle}¬∞ | Compass: {compass_dir}")
    
    # ‡∏´‡∏°‡∏∏‡∏ô gimbal ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏°‡∏∏‡∏°‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
    gimbal.moveto(pitch=-20, yaw=angle, pitch_speed=speed, yaw_speed=speed).wait_for_completed()
    time.sleep(0.3)  # ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏Å‡∏¥‡∏°‡∏ö‡∏≠‡∏•‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£
    
    # ‡∏ß‡∏±‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á
    tof_handler.start_scanning('temp_scan')
    sensor.sub_distance(freq=50, callback=tof_handler.tof_data_handler)
    time.sleep(0.15)
    tof_handler.stop_scanning(sensor.unsub_distance)
    
    distance = tof_handler.get_average_distance('temp_scan')
    print(f"   üìê Distance: {distance:.2f}cm at {angle}¬∞")
    
    marker_ids = []
    
    # ‡∏ï‡∏£‡∏ß‡∏à marker ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ñ‡πâ‡∏≤‡∏£‡∏∞‡∏¢‡∏∞‡πÉ‡∏Å‡∏•‡πâ‡∏û‡∏≠ ‡πÅ‡∏•‡∏∞‡∏°‡∏µ ToF reading ‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    if distance > 0 and distance <= 40.0:
        print("‚úÖ Distance OK - Scanning for markers...")
        
        # ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÅ‡∏•‡∏∞‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏™‡πÅ‡∏Å‡∏ô marker
        marker_handler.reset_detection()
        detected = marker_handler.wait_for_markers(timeout=1.0)
        
        if detected and marker_handler.markers:
            marker_ids = [m.id for m in marker_handler.markers]
            print(f"üéØ FOUND MARKERS: {marker_ids}")
            print(f"   üìç Direction: {direction_name} ({angle}¬∞)")
            print(f"   üìè Distance: {distance:.2f}cm")
            print(f"   üß≠ Compass: {compass_dir}")
        else:
            print(f"‚ùå No markers found at {direction_name} ({angle}¬∞)")
    else:
        if distance <= 0:
            print(f"‚ùå Invalid ToF reading ({distance:.2f}cm) at {angle}¬∞ - Skipping marker detection")
        else:
            print(f"‚ùå Distance too far ({distance:.2f}cm > 40cm) at {angle}¬∞ - Skipping marker detection")
    
    return {
        'marker_ids': marker_ids,
        'distance': distance,
        'direction_name': direction_name,
        'angle': angle,
        'compass_direction': compass_dir,
        'timestamp': datetime.now().isoformat()
    }

# ===== Red Color Detection Function =====
def detect_red(ep_camera, threshold_area=100, attempts=3):
    """
    ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏à‡∏≤‡∏Å‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤
    ‡∏≠‡πà‡∏≤‡∏ô frame ‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á (attempts) ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô queue empty
    ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ True/False ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠‡∏™‡∏µ‡πÅ‡∏î‡∏á
    """
    try:
        for _ in range(attempts):
            try:
                frame = ep_camera.read_cv2_image(strategy="newest", timeout=0.5)
                if frame is None:
                    continue
                    
                hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

                # ‡∏ä‡πà‡∏ß‡∏á‡∏™‡∏µ‡πÅ‡∏î‡∏á (‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÅ‡∏•‡πâ‡∏ß‡πÉ‡∏´‡πâ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô)
                lower_red1 = np.array([0, 120, 70])
                upper_red1 = np.array([10, 255, 255])
                lower_red2 = np.array([170, 120, 70])
                upper_red2 = np.array([180, 255, 255])

                mask1 = cv2.inRange(hsv, lower_red1, upper_red1)
                mask2 = cv2.inRange(hsv, lower_red2, upper_red2)
                mask = mask1 | mask2

                contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                for cnt in contours:
                    if cv2.contourArea(cnt) > threshold_area:
                        return True
                        
                # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡∏™‡∏µ‡πÅ‡∏î‡∏á‡πÉ‡∏ô frame ‡∏ô‡∏µ‡πâ ‡πÉ‡∏´‡πâ‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà
                time.sleep(0.05)
                
            except Exception as e:
                print(f"‚ùå Error reading frame: {e}")
                time.sleep(0.1)
                
        return False
    except Exception as e:
        print(f"‚ùå detect_red error: {e}")
        return False

def scan_red_then_marker_enhanced(ep_robot, gimbal, chassis, sensor, marker_handler, tof_handler):
    """
    Enhanced version: ‡∏™‡πÅ‡∏Å‡∏ô‡∏´‡∏≤‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡πÅ‡∏Å‡∏ô marker ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≠‡∏™‡∏µ‡πÅ‡∏î‡∏á
    ‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏ó‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πÅ‡∏Å‡∏ô marker ‡∏ó‡∏∏‡∏Å‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á
    """
    yaw_angles = [0, -90, 90]  # ‡∏´‡∏ô‡πâ‡∏≤, ‡∏ã‡πâ‡∏≤‡∏¢, ‡∏Ç‡∏ß‡∏≤
    red_angles = []
    results = {}

    ep_camera = ep_robot.camera
    
    # ‡πÄ‡∏õ‡∏¥‡∏î Video Stream ‡πÅ‡∏•‡∏∞‡∏£‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£
    try:
        ep_camera.start_video_stream(display=False, resolution="720p")
        print("üìπ Starting camera stream for red detection...")
        time.sleep(1.0)  # ‡∏£‡∏≠‡πÉ‡∏´‡πâ frame ‡∏°‡∏≤‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£
    except Exception as e:
        print(f"‚ùå Error starting camera: {e}")
        return {}

    # ‡∏•‡πá‡∏≠‡∏Ñ‡∏•‡πâ‡∏≠‡∏´‡∏∏‡πà‡∏ô‡∏¢‡∏ô‡∏ï‡πå
    chassis.drive_wheels(w1=0, w2=0, w3=0, w4=0)

    print("\nüî¥ === SCANNING FOR RED COLOR ===")
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏µ‡πÅ‡∏î‡∏á‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á
    for yaw in yaw_angles:
        direction_name = get_direction_name(yaw)
        print(f"\nüîÑ ‡∏´‡∏°‡∏∏‡∏ô Gimbal ‡πÑ‡∏õ‡∏ó‡∏µ‡πà {direction_name} ({yaw}¬∞) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏™‡∏µ‡πÅ‡∏î‡∏á")
        
        gimbal.moveto(pitch=0, yaw=yaw, pitch_speed=480, yaw_speed=480).wait_for_completed()
        time.sleep(0.3)  # ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£
        
        found_red = detect_red(ep_camera, threshold_area=100, attempts=5)
        if found_red:
            print(f"‚úÖ ‡πÄ‡∏à‡∏≠‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏ó‡∏µ‡πà {direction_name} ({yaw}¬∞)")
            red_angles.append(yaw)
        else:
            print(f"‚ùå ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏ó‡∏µ‡πà {direction_name} ({yaw}¬∞)")

    # ‡∏õ‡∏¥‡∏î Video Stream ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏µ‡πÅ‡∏î‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à
    try:
        ep_camera.stop_video_stream()
    except:
        pass

    if not red_angles:
        print("\n‚ùå ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡∏™‡∏µ‡πÅ‡∏î‡∏á‡πÉ‡∏ô‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡πÉ‡∏î‡πÄ‡∏•‡∏¢")
        # ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á
        gimbal.moveto(pitch=0, yaw=0, pitch_speed=480, yaw_speed=480).wait_for_completed()
        chassis.drive_wheels(w1=0, w2=0, w3=0, w4=0)
        return results

    print(f"\nüéØ === SCANNING MARKERS (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≠‡∏™‡∏µ‡πÅ‡∏î‡∏á) ===")
    print(f"üî¥ ‡πÄ‡∏à‡∏≠‡∏™‡∏µ‡πÅ‡∏î‡∏á‡πÉ‡∏ô {len(red_angles)} ‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á: {red_angles}")

    # scan marker ‡πÄ‡∏â‡∏û‡∏≤‡∏∞ yaw ‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≠‡∏™‡∏µ‡πÅ‡∏î‡∏á
    for yaw in red_angles:
        direction_name = get_direction_name(yaw)
        direction_key = direction_name.split(' ')[0].lower()  # Extract direction (front, left, right)
        
        print(f"\nüéØ ‡∏™‡πÅ‡∏Å‡∏ô Marker ‡∏ó‡∏µ‡πà {direction_name} ({yaw}¬∞)")
        
        marker_scan_result = scan_for_markers_at_direction(gimbal, sensor, yaw, direction_key, marker_handler, tof_handler, speed=480)
        
        results[direction_key] = {
            'direction_name': direction_name,
            'marker_ids': marker_scan_result['marker_ids'],
            'distance': marker_scan_result['distance'],
            'found_red': True,
            'angle': yaw,
            'compass_direction': marker_scan_result['compass_direction'],
            'timestamp': marker_scan_result['timestamp']
        }
        
        if marker_scan_result['marker_ids']:
            print(f"üéØ ‡πÄ‡∏à‡∏≠ Marker: {marker_scan_result['marker_ids']} ‡∏ó‡∏µ‡πà {direction_name} ({yaw}¬∞)")
        else:
            print(f"‚ùå ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ Marker ‡∏ó‡∏µ‡πà {direction_name} ({yaw}¬∞)")

    # ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á
    print(f"\nüîÑ ‡∏Å‡∏•‡∏±‡∏ö‡∏™‡∏π‡πà‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á...")
    gimbal.moveto(pitch=0, yaw=0, pitch_speed=480, yaw_speed=480).wait_for_completed()
    
    # ‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ‡∏•‡πâ‡∏≠
    chassis.drive_wheels(w1=0, w2=0, w3=0, w4=0, timeout=0.1)

    return results

# ===== Main Exploration Functions =====
def scan_current_node_absolute(gimbal, chassis, sensor, tof_handler, graph_mapper, marker_handler=None, ep_robot=None):
    """NEW: Scan current node and update graph with ABSOLUTE directions + RED-FILTERED MARKER DETECTION"""
    print(f"\nüó∫Ô∏è === Scanning Node at {graph_mapper.currentPosition} ===")
    
    current_node = graph_mapper.create_node(graph_mapper.currentPosition)
    
    # Check if node has been fully scanned before
    if current_node.fullyScanned:
        print(f"üîÑ Node {current_node.id} already fully scanned - using cached data!")
        print(f"   üß± Cached walls (absolute): {current_node.walls}")
        print(f"   üîç Cached unexplored exits: {current_node.unexploredExits}")
        if current_node.sensorReadings:
            print(f"   üì° Cached sensor readings:")
            for direction, reading in current_node.sensorReadings.items():
                print(f"      {direction}: {reading:.2f}cm")
        # ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• marker ‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡∏™‡πÅ‡∏Å‡∏ô‡πÑ‡∏ß‡πâ
        if hasattr(current_node, 'markersFound') and current_node.markersFound:
            print(f"   üéØ Cached markers found:")
            for direction, marker_ids in current_node.markersFound.items():
                print(f"      {direction}: {marker_ids}")
        print("‚ö° Skipping physical scan - using cached data")
        return current_node.sensorReadings
    
    # Only scan if node hasn't been fully scanned before
    print(f"üÜï First time visiting node {current_node.id} - performing full scan")
    print(f"üß≠ Robot currently facing: {graph_mapper.currentDirection}")
    
    # Lock wheels
    chassis.drive_wheels(w1=0, w2=0, w3=0, w4=0)
    time.sleep(0.2)
    
    speed = 480
    scan_results = {}
    red_directions = []  # ‡πÄ‡∏Å‡πá‡∏ö‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≠‡∏™‡∏µ‡πÅ‡∏î‡∏á
    
    # ===== ‡πÄ‡∏õ‡∏¥‡∏î Video Stream ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏µ‡πÅ‡∏î‡∏á =====
    ep_camera = None
    if marker_handler and ep_robot:
        try:
            ep_camera = ep_robot.camera
            ep_camera.start_video_stream(display=False, resolution="720p")
            print("üìπ Video stream started for red color detection")
            time.sleep(0.5)  # ‡∏£‡∏≠‡πÉ‡∏´‡πâ camera ‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£
        except Exception as e:
            print(f"‚ö†Ô∏è Cannot start video stream for red detection: {e}")
            ep_camera = None
    
    # ===== SCAN FRONT (0¬∞) - ToF + Red Detection =====
    print("üîç Scanning FRONT (0¬∞) - ToF + Red Detection...")
    gimbal.moveto(pitch=0, yaw=0, pitch_speed=speed, yaw_speed=speed).wait_for_completed()
    time.sleep(0.2)
    
    # ToF scan
    tof_handler.start_scanning('front')
    sensor.sub_distance(freq=25, callback=tof_handler.tof_data_handler)
    time.sleep(0.2)
    tof_handler.stop_scanning(sensor.unsub_distance)
    
    front_distance = tof_handler.get_average_distance('front')
    front_wall = tof_handler.is_wall_detected('front')
    scan_results['front'] = front_distance
    
    print(f"üìè FRONT ToF result: {front_distance:.2f}cm - {'WALL' if front_wall else 'OPEN'}")
    
    # Red detection at FRONT
    if ep_camera and front_distance > 0 and front_distance <= 40.0:
        print("üî¥ Checking for red color at FRONT...")
        found_red = detect_red(ep_camera, threshold_area=100, attempts=3)
        if found_red:
            print("‚úÖ RED DETECTED at FRONT!")
            red_directions.append(('front', 0))
        else:
            print("‚ùå No red at FRONT")

    # Position adjustment if too close
    if front_distance <= 19.0:
        move_distance = -(23 - front_distance)
        print(f"‚ö†Ô∏è FRONT too close ({front_distance:.2f}cm)! Moving back {move_distance:.2f}m")
        ep_chassis.move(x=move_distance/100, y=0, xy_speed=0.2).wait_for_completed()
        time.sleep(0.2)

    # ===== SCAN LEFT (-90¬∞) - ToF + Red Detection =====
    print("üîç Scanning LEFT (-90¬∞) - ToF + Red Detection...")
    gimbal.moveto(pitch=0, yaw=-90, pitch_speed=speed, yaw_speed=speed).wait_for_completed()
    time.sleep(0.2)
    
    # ToF scan
    tof_handler.start_scanning('left')
    sensor.sub_distance(freq=25, callback=tof_handler.tof_data_handler)
    time.sleep(0.2)
    tof_handler.stop_scanning(sensor.unsub_distance)
    
    left_distance = tof_handler.get_average_distance('left')
    left_wall = tof_handler.is_wall_detected('left')
    scan_results['left'] = left_distance
    
    print(f"üìè LEFT ToF result: {left_distance:.2f}cm - {'WALL' if left_wall else 'OPEN'}")
    
    # Red detection at LEFT
    if ep_camera and left_distance > 0 and left_distance <= 40.0:
        print("üî¥ Checking for red color at LEFT...")
        found_red = detect_red(ep_camera, threshold_area=100, attempts=3)
        if found_red:
            print("‚úÖ RED DETECTED at LEFT!")
            red_directions.append(('left', -90))
        else:
            print("‚ùå No red at LEFT")

    # Position adjustment if too close
    if left_distance < 15:
        move_distance = 20 - left_distance
        print(f"‚ö†Ô∏è LEFT too close ({left_distance:.2f}cm)! Moving right {move_distance:.2f}m")
        ep_chassis.move(x=0.01, y=move_distance/100, xy_speed=0.5).wait_for_completed()
        time.sleep(0.3)

    # ===== SCAN RIGHT (90¬∞) - ToF + Red Detection =====
    print("üîç Scanning RIGHT (90¬∞) - ToF + Red Detection...")
    gimbal.moveto(pitch=0, yaw=90, pitch_speed=speed, yaw_speed=speed).wait_for_completed()
    time.sleep(0.2)
    
    # ToF scan
    tof_handler.start_scanning('right')
    sensor.sub_distance(freq=25, callback=tof_handler.tof_data_handler)
    time.sleep(0.2)
    tof_handler.stop_scanning(sensor.unsub_distance)
    
    right_distance = tof_handler.get_average_distance('right')
    right_wall = tof_handler.is_wall_detected('right')
    scan_results['right'] = right_distance

    print(f"üìè RIGHT ToF result: {right_distance:.2f}cm - {'WALL' if right_wall else 'OPEN'}")
    
    # Red detection at RIGHT
    if ep_camera and right_distance > 0 and right_distance <= 40.0:
        print("üî¥ Checking for red color at RIGHT...")
        found_red = detect_red(ep_camera, threshold_area=100, attempts=3)
        if found_red:
            print("‚úÖ RED DETECTED at RIGHT!")
            red_directions.append(('right', 90))
        else:
            print("‚ùå No red at RIGHT")

    # Position adjustment if too close
    if right_distance < 15:
        move_distance = -(21 - right_distance)
        print(f"‚ö†Ô∏è RIGHT too close ({right_distance:.2f}cm)! Moving left {move_distance:.2f}m")
        ep_chassis.move(x=0.01, y=move_distance/100, xy_speed=0.5).wait_for_completed()
        time.sleep(0.3)

    # ===== SPECIAL BACK SCAN FOR INITIAL NODE =====
    if graph_mapper.currentPosition == (0, 0) and current_node.initialScanDirection == graph_mapper.currentDirection:
        print("üîç Special check: scanning BACK at start node...")
        gimbal.moveto(pitch=0, yaw=180, pitch_speed=speed, yaw_speed=speed).wait_for_completed()
        time.sleep(0.2)

        # ToF scan for back
        tof_handler.start_scanning('back')
        sensor.sub_distance(freq=25, callback=tof_handler.tof_data_handler)
        time.sleep(0.2)
        tof_handler.stop_scanning(sensor.unsub_distance)

        back_distance = tof_handler.get_average_distance('back')
        back_wall = tof_handler.is_wall_detected('back')
        scan_results['back'] = back_distance
        
        print(f"üìè BACK ToF result: {back_distance:.2f}cm - {'WALL' if back_wall else 'OPEN'}")

        # Red detection at BACK
        if ep_camera and back_distance > 0 and back_distance <= 40.0:
            print("üî¥ Checking for red color at BACK...")
            found_red = detect_red(ep_camera, threshold_area=100, attempts=3)
            if found_red:
                print("‚úÖ RED DETECTED at BACK!")
                red_directions.append(('back', 180))
            else:
                print("‚ùå No red at BACK")

        # Update walls for back direction
        direction_map = {
            'north': 'south',
            'south': 'north',
            'east': 'west',
            'west': 'east'
        }
        back_abs_dir = direction_map[graph_mapper.currentDirection]
        current_node.walls[back_abs_dir] = back_wall
        current_node.wallBack = back_wall

        if back_wall and back_abs_dir in current_node.unexploredExits:
            current_node.unexploredExits.remove(back_abs_dir)
            print(f"üßπ Removed BACK ({back_abs_dir}) from unexplored exits at start node")

    # ===== ‡∏õ‡∏¥‡∏î Video Stream =====
    if ep_camera:
        try:
            ep_camera.stop_video_stream()
            print("üìπ Video stream stopped")
        except:
            pass

    # ===== MARKER SCANNING - ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≠‡∏™‡∏µ‡πÅ‡∏î‡∏á =====
    if marker_handler and red_directions:
        print(f"\nüéØ === MARKER SCANNING (Red-filtered) ===")
        print(f"üî¥ Found red in {len(red_directions)} directions: {[d[0] for d in red_directions]}")
        
        for direction_name, angle in red_directions:
            print(f"\nüéØ Scanning markers at {direction_name.upper()} ({angle}¬∞) where red was detected...")
            
            # ‡∏´‡∏°‡∏∏‡∏ô‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡∏°‡∏∏‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≠‡∏™‡∏µ‡πÅ‡∏î‡∏á‡πÅ‡∏•‡∏∞‡∏Å‡πâ‡∏°‡∏•‡∏á (-20¬∞)
            gimbal.moveto(pitch=-20, yaw=angle, pitch_speed=speed, yaw_speed=speed).wait_for_completed()
            time.sleep(0.3)
            
            # ‡∏ß‡∏±‡∏î‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà (‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏Å‡πâ‡∏°‡∏•‡∏á‡πÅ‡∏•‡πâ‡∏ß)
            tof_handler.start_scanning('marker_scan')
            sensor.sub_distance(freq=50, callback=tof_handler.tof_data_handler)
            time.sleep(0.15)
            tof_handler.stop_scanning(sensor.unsub_distance)
            
            marker_distance = tof_handler.get_average_distance('marker_scan')
            print(f"   üìê Marker scan distance (tilted): {marker_distance:.2f}cm")
            
            # ‡∏ï‡∏£‡∏ß‡∏à marker
            marker_ids = []
            if marker_distance > 0 and marker_distance <= 40.0:
                print("   ‚úÖ Distance OK - Scanning for markers...")
                marker_handler.reset_detection()
                detected = marker_handler.wait_for_markers(timeout=1.0)
                
                if detected and marker_handler.markers:
                    marker_ids = [m.id for m in marker_handler.markers]
                    print(f"   üéØ FOUND MARKERS: {marker_ids}")
                else:
                    print(f"   ‚ùå No markers found")
            else:
                print(f"   ‚ùå Distance not suitable for marker detection: {marker_distance:.2f}cm")
            
            # ‡πÄ‡∏Å‡πá‡∏ö‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå
            current_node.markerScanResults[direction_name] = {
                'marker_ids': marker_ids,
                'distance': marker_distance,
                'direction_name': direction_name,
                'angle': angle,
                'compass_direction': get_compass_direction(angle),
                'timestamp': datetime.now().isoformat(),
                'found_red': True
            }
            
            if marker_ids:
                current_node.markersFound[direction_name] = marker_ids
                current_node.hasMarkers = True
                print(f"   ‚úÖ Stored markers for {direction_name}: {marker_ids}")
    
    elif marker_handler:
        print(f"\nüî¥ No red color detected in any direction - skipping marker scanning")
    
    # Return to center
    gimbal.moveto(pitch=0, yaw=0, pitch_speed=speed, yaw_speed=speed).wait_for_completed()
    time.sleep(0.2)
    
    # Unlock wheels
    chassis.drive_wheels(w1=0, w2=0, w3=0, w4=0, timeout=0.1)
    time.sleep(0.2)
    
    # Update graph with wall information using ABSOLUTE directions
    graph_mapper.update_current_node_walls_absolute(left_wall, right_wall, front_wall)
    current_node.sensorReadings = scan_results
    
    print(f"‚úÖ Node {current_node.id} scan complete:")
    print(f"   üß± Walls detected (relative): Left={left_wall}, Right={right_wall}, Front={front_wall}")
    print(f"   üß± Walls stored (absolute): {current_node.walls}")
    print(f"   üìè Distances: Left={left_distance:.1f}cm, Right={right_distance:.1f}cm, Front={front_distance:.1f}cm")
    
    # ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏£‡∏∏‡∏õ marker ‡∏ó‡∏µ‡πà‡∏û‡∏ö
    if hasattr(current_node, 'markersFound') and current_node.markersFound:
        print(f"   üéØ Markers summary:")
        for direction, marker_ids in current_node.markersFound.items():
            print(f"      {direction.upper()}: {marker_ids}")
    
    return scan_results

def explore_autonomously_with_absolute_directions(gimbal, chassis, sensor, tof_handler, graph_mapper, movement_controller, attitude_handler, marker_handler=None, ep_robot=None, max_nodes=20):
    """Main autonomous exploration with attitude drift correction INCLUDING BACKTRACKING + RED-FILTERED MARKER DETECTION"""
    print("\nüöÄ === STARTING AUTONOMOUS EXPLORATION WITH RED-FILTERED MARKER DETECTION ===")
    print(f"üéØ Wall Detection Threshold: {tof_handler.WALL_THRESHOLD}cm")
    print(f"üîß Attitude Drift Correction: Every {movement_controller.DRIFT_CORRECTION_INTERVAL} nodes (+{movement_controller.DRIFT_CORRECTION_ANGLE}¬∞ right)")
    if marker_handler:
        print(f"üî¥ Red Color Filtering: Enabled - markers scanned only where red detected")
        print(f"üìê Marker Scan Mode: Gimbal tilt to -20¬∞ for optimal detection")
    else:
        print(f"‚ö†Ô∏è Marker Detection: Disabled")
    
    nodes_explored = 0
    scanning_iterations = 0
    dead_end_reversals = 0
    backtrack_attempts = 0
    reverse_backtracks = 0
    
    while nodes_explored < max_nodes:
        print(f"\n{'='*50}")
        print(f"--- EXPLORATION STEP {nodes_explored + 1} ---")
        print(f"ü§ñ Current position: {graph_mapper.currentPosition}")
        print(f"üß≠ Current direction (absolute): {graph_mapper.currentDirection}")
        
        # ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ drift correction
        drift_status = movement_controller.get_drift_correction_status()
        print(f"üîß Comprehensive Drift Correction Status:")
        print(f"   üìä Total nodes visited (including backtrack): {drift_status['nodes_visited']}")
        print(f"   ‚è≥ Next correction at node: {drift_status['next_correction_at']}")
        print(f"   ‚è∞ Nodes until correction: {drift_status['nodes_until_correction']}")
        print(f"   üîÑ Total corrections done: {drift_status['total_corrections']}")
        print(f"   üìç Last correction at node: {drift_status['last_correction_at']}")
        print(f"{'='*50}")
        
        # *** ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÇ‡∏´‡∏ô‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö main exploration ‡πÅ‡∏•‡∏∞‡πÄ‡∏ä‡πá‡∏Ñ drift correction ***
        needs_drift_correction = movement_controller.increment_node_visit_main_exploration(attitude_handler)
        
        if needs_drift_correction:
            print(f"‚úÖ Main exploration drift correction completed!")
        
        # Check if current node needs scanning
        current_node = graph_mapper.create_node(graph_mapper.currentPosition)
        
        if not current_node.fullyScanned:
            print("üîç NEW NODE - Performing full scan...")
            scan_results = scan_current_node_absolute(gimbal, chassis, sensor, tof_handler, graph_mapper, marker_handler, ep_robot)
            scanning_iterations += 1
            
            # Check if this scan revealed a dead end
            if graph_mapper.is_dead_end(current_node):
                print(f"üö´ DEAD END DETECTED after scanning!")
                print(f"üîô Initiating reverse maneuver...")
                
                success = graph_mapper.handle_dead_end(movement_controller)
                if success:
                    dead_end_reversals += 1
                    print(f"‚úÖ Successfully reversed from dead end (Total reversals: {dead_end_reversals})")
                    nodes_explored += 1
                    continue
                else:
                    print(f"‚ùå Failed to reverse from dead end!")
                    break
        else:
            print("‚ö° REVISITED NODE - Using cached scan data (no physical scanning)")
            graph_mapper.update_unexplored_exits_absolute(current_node)
            graph_mapper.build_connections()
        
        nodes_explored += 1
        
        # Print current graph state
        graph_mapper.print_graph_summary()
        
        # Find next direction to explore
        graph_mapper.previous_node = current_node
        
        # STEP 1: Try to find unexplored direction from current node
        next_direction = graph_mapper.find_next_exploration_direction()
        
        if next_direction:
            print(f"\nüéØ Next exploration direction (absolute): {next_direction}")
            
            can_move = graph_mapper.can_move_to_direction_absolute(next_direction)
            print(f"üö¶ Movement check: {'ALLOWED' if can_move else 'BLOCKED'}")
            
            if can_move:
                try:
                    success = graph_mapper.move_to_absolute_direction(next_direction, movement_controller, attitude_handler)
                    if success:
                        print(f"‚úÖ Successfully moved to {graph_mapper.currentPosition}")
                        time.sleep(0.2)
                        continue
                    else:
                        print(f"‚ùå Movement failed - wall detected!")
                        if current_node and next_direction in current_node.unexploredExits:
                            current_node.unexploredExits.remove(next_direction)
                        continue
                    
                except Exception as e:
                    print(f"‚ùå Error during movement: {e}")
                    break
            else:
                print(f"üö´ Cannot move to {next_direction} - blocked by wall!")
                if current_node and next_direction in current_node.unexploredExits:
                    current_node.unexploredExits.remove(next_direction)
                continue
        
        # STEP 2: Backtracking logic
        backtrack_attempts += 1
        
        frontier_id, frontier_direction, path = graph_mapper.find_nearest_frontier()
        
        if frontier_id and path is not None and frontier_direction:
            print(f"üéØ Found frontier node {frontier_id} with unexplored direction: {frontier_direction}")
            print(f"üó∫Ô∏è Path to frontier: {path} (distance: {len(path)} steps)")
            print("üîô REVERSE BACKTRACK: Using reverse movements WITH drift correction!")
            
            try:
                # *** ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÉ‡∏ä‡πâ‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á attitude_handler ‡πÑ‡∏õ‡∏î‡πâ‡∏ß‡∏¢ ***
                success = graph_mapper.execute_path_to_frontier_with_reverse(path, movement_controller, attitude_handler)
                
                if success:
                    reverse_backtracks += 1
                    print(f"‚úÖ Successfully REVERSE backtracked to frontier at {graph_mapper.currentPosition}")
                    print(f"   üìä Total reverse backtracks: {reverse_backtracks}")
                    
                    # ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ drift correction ‡∏´‡∏•‡∏±‡∏á backtrack
                    updated_drift_status = movement_controller.get_drift_correction_status()
                    print(f"   üîß Total nodes after backtrack: {updated_drift_status['nodes_visited']}")
                    print(f"   üîÑ Total corrections: {updated_drift_status['total_corrections']}")
                    
                    time.sleep(0.2)
                    continue
                    
                else:
                    print(f"‚ùå Failed to execute reverse backtracking path!")
                    break
                    
            except Exception as e:
                print(f"‚ùå Error during reverse backtracking: {e}")
                break
        else:
            # STEP 3: Final check
            print("üéâ No more frontiers found!")
            print("üîÑ Performing final frontier scan...")
            graph_mapper.rebuild_frontier_queue()
            
            if graph_mapper.frontierQueue:
                print(f"üöÄ Found {len(graph_mapper.frontierQueue)} missed frontiers - continuing...")
                continue
            else:
                print("üéâ EXPLORATION DEFINITELY COMPLETE!")
                break
        
        if nodes_explored >= max_nodes:
            print(f"‚ö†Ô∏è Reached maximum nodes limit ({max_nodes})")
            break
    
    # Final statistics
    final_drift_status = movement_controller.get_drift_correction_status()
    
    print(f"\nüéâ === EXPLORATION COMPLETED ===")
    print(f"üìä PERFORMANCE SUMMARY:")
    print(f"   üó∫Ô∏è Total exploration steps: {nodes_explored}")
    print(f"   üìä Total nodes visited (including backtrack): {final_drift_status['nodes_visited']}")
    print(f"   üîç Physical scans performed: {scanning_iterations}")
    print(f"   üîô Dead end reversals: {dead_end_reversals}")
    print(f"   üîÑ Backtrack attempts: {backtrack_attempts}")
    print(f"   üîô Reverse backtracks: {reverse_backtracks}")
    print(f"   ‚ö° Scans saved by caching: {nodes_explored - scanning_iterations}")
    
    print(f"\nüîß COMPREHENSIVE ATTITUDE DRIFT CORRECTION SUMMARY:")
    print(f"   üìä Total nodes counted: {final_drift_status['nodes_visited']} (exploration + backtracking)")
    print(f"   üîÑ Total corrections performed: {final_drift_status['total_corrections']}")
    print(f"   üéØ Total angle corrected: {final_drift_status['total_corrections'] * final_drift_status['correction_angle']}¬∞")
    print(f"   üìç Correction interval: Every {final_drift_status['correction_interval']} nodes")
    print(f"   üîß Correction angle: +{final_drift_status['correction_angle']}¬∞ per correction")
    print(f"   üìà Last correction at node: {final_drift_status['last_correction_at']}")
    
    backtrack_node_count = final_drift_status['nodes_visited'] - nodes_explored
    if final_drift_status['nodes_visited'] > 0:
        drift_frequency = final_drift_status['total_corrections'] / final_drift_status['nodes_visited']
        backtrack_percentage = (backtrack_node_count / final_drift_status['nodes_visited']) * 100
        print(f"   üìä Drift correction frequency: {drift_frequency:.2f} corrections per total node")
        print(f"   üîô Backtrack nodes: {backtrack_node_count} ({backtrack_percentage:.1f}% of total)")
    
    graph_mapper.print_graph_summary()
    generate_exploration_report_absolute(graph_mapper, nodes_explored, dead_end_reversals, reverse_backtracks, final_drift_status)


def generate_exploration_report_absolute(graph_mapper, nodes_explored, dead_end_reversals=0, reverse_backtracks=0, final_drift_status=None):
    """Generate comprehensive exploration report with absolute direction info"""
    print(f"\n{'='*60}")
    print("üìã FINAL EXPLORATION REPORT (ABSOLUTE DIRECTIONS)")
    print(f"{'='*60}")
    
    # Basic statistics
    total_nodes = len(graph_mapper.nodes)
    dead_ends = sum(1 for node in graph_mapper.nodes.values() if node.isDeadEnd)
    frontier_nodes = len(graph_mapper.frontierQueue)
    fully_scanned_nodes = sum(1 for node in graph_mapper.nodes.values() if node.fullyScanned)
    
    # NEW: Marker statistics
    nodes_with_markers = sum(1 for node in graph_mapper.nodes.values() if hasattr(node, 'hasMarkers') and node.hasMarkers)
    total_markers_found = 0
    markers_by_direction = {'front': 0, 'left': 0, 'right': 0, 'back': 0}
    
    for node in graph_mapper.nodes.values():
        if hasattr(node, 'markersFound') and node.markersFound:
            for direction, marker_ids in node.markersFound.items():
                total_markers_found += len(marker_ids)
                if direction in markers_by_direction:
                    markers_by_direction[direction] += len(marker_ids)
    
    print(f"üìä STATISTICS:")
    print(f"   üèÅ Total nodes explored: {total_nodes}")
    print(f"   üéØ Node visits: {nodes_explored}")
    print(f"   üîç Fully scanned nodes: {fully_scanned_nodes}")
    print(f"   üö´ Dead ends found: {dead_ends}")
    print(f"   üîô Dead end reversals performed: {dead_end_reversals}")
    print(f"   üîô Reverse backtracks performed: {reverse_backtracks}")
    print(f"   üöÄ Remaining frontiers: {frontier_nodes}")
    
    # NEW: Red-filtered marker detection summary
    print(f"\nüéØ RED-FILTERED MARKER DETECTION SUMMARY:")
    print(f"   üìç Nodes with markers: {nodes_with_markers}")
    print(f"   üéØ Total markers found: {total_markers_found}")
    
    # Count red detections from marker scan results
    red_detections = 0
    for node in graph_mapper.nodes.values():
        if hasattr(node, 'markerScanResults') and node.markerScanResults:
            for direction, scan_result in node.markerScanResults.items():
                if scan_result.get('found_red', False):
                    red_detections += 1
    
    print(f"   üî¥ Red color detections: {red_detections}")
    if total_markers_found > 0:
        print(f"   üìä Markers by direction:")
        for direction, count in markers_by_direction.items():
            if count > 0:
                print(f"      {direction.upper()}: {count} markers")
        print(f"   üìà Marker detection rate: {nodes_with_markers/total_nodes*100:.1f}% of nodes")
        if red_detections > 0:
            print(f"   üéØ Marker success rate from red: {total_markers_found/red_detections*100:.1f}% when red detected")
    
    # Efficiency metrics
    revisited_nodes = nodes_explored - total_nodes
    if revisited_nodes > 0:
        print(f"   üîÑ Node revisits (backtracking): {revisited_nodes}")
        print(f"   ‚ö° Scans saved by caching: {revisited_nodes}")
        print(f"   üìà Scanning efficiency: {(revisited_nodes / nodes_explored * 100):.1f}% improvement")
    
    # Map boundaries
    if graph_mapper.nodes:
        positions = [node.position for node in graph_mapper.nodes.values()]
        min_x = min(pos[0] for pos in positions)
        max_x = max(pos[0] for pos in positions)
        min_y = min(pos[1] for pos in positions)
        max_y = max(pos[1] for pos in positions)
        
        print(f"\nüó∫Ô∏è MAP BOUNDARIES:")
        print(f"   X range: {min_x} to {max_x} (width: {max_x - min_x + 1})")
        print(f"   Y range: {min_y} to {max_y} (height: {max_y - min_y + 1})")
    
    # Wall statistics using absolute directions
    wall_stats = {'north': 0, 'south': 0, 'east': 0, 'west': 0}
    opening_stats = {'north': 0, 'south': 0, 'east': 0, 'west': 0}
    
    for node in graph_mapper.nodes.values():
        if hasattr(node, 'walls') and node.walls:
            for direction, is_wall in node.walls.items():
                if is_wall:
                    wall_stats[direction] += 1
                else:
                    opening_stats[direction] += 1
    
    print(f"\nüß± WALL ANALYSIS (ABSOLUTE DIRECTIONS):")
    total_walls = sum(wall_stats.values())
    total_openings = sum(opening_stats.values())
    
    print(f"   Total walls detected: {total_walls}")
    print(f"   Total openings detected: {total_openings}")
    if (total_walls + total_openings) > 0:
        print(f"   Wall density: {total_walls/(total_walls+total_openings)*100:.1f}%")
    
    print(f"   Walls by direction:")
    for direction in ['north', 'south', 'east', 'west']:
        total_dir = wall_stats[direction] + opening_stats[direction]
        if total_dir > 0:
            wall_pct = wall_stats[direction] / total_dir * 100
            print(f"      {direction.upper()}: {wall_stats[direction]} walls, {opening_stats[direction]} openings ({wall_pct:.1f}% walls)")
    
    # Movement efficiency summary
    print(f"\nüîô MOVEMENT EFFICIENCY:")
    print(f"   Dead end reversals: {dead_end_reversals}")
    print(f"   Reverse backtracks: {reverse_backtracks}")
    print(f"   Total reverse movements: {dead_end_reversals + reverse_backtracks}")
    print(f"   Time saved vs 180¬∞ turns: ~{(dead_end_reversals + reverse_backtracks) * 2:.1f} seconds")
    
    # Unexplored areas
    if graph_mapper.frontierQueue:
        print(f"\nüîç UNEXPLORED AREAS:")
        for frontier_id in graph_mapper.frontierQueue:
            node = graph_mapper.nodes[frontier_id]
            print(f"   üìç {node.position}: {len(node.unexploredExits)} unexplored exits {node.unexploredExits}")
    
    print(f"\n‚≠ê ABSOLUTE DIRECTION BENEFITS:")
    print(f"   üî¥ Red color filtering integrated with ToF scanning")
    print(f"   üéØ Smart marker detection only where red color detected")
    print(f"   üîÑ Efficient scanning: Red detection at 0¬∞, -90¬∞, 90¬∞ (and 180¬∞ for initial node)")
    print(f"   üìê Gimbal tilt (-20¬∞) for marker scanning only in red-filtered directions")
    print(f"   üìä Comprehensive marker tracking per node and direction")
    print(f"   ‚ö° Performance optimized: Skip marker scanning where no red detected")
    
    print(f"\n{'='*60}")
    print("‚úÖ ABSOLUTE DIRECTION EXPLORATION WITH RED-FILTERED MARKER DETECTION COMPLETE")
    print(f"{'='*60}")

def convert_to_json_serializable(obj):
    """Convert numpy types and other non-serializable types to JSON-serializable types"""
    import numpy as np
    
    if isinstance(obj, (np.bool_, bool)):
        return bool(obj)
    elif isinstance(obj, (np.integer, int)):
        return int(obj)
    elif isinstance(obj, (np.floating, float)):
        return float(obj)
    elif isinstance(obj, (np.ndarray, list, tuple)):
        return [convert_to_json_serializable(item) for item in obj]
    elif isinstance(obj, dict):
        return {key: convert_to_json_serializable(value) for key, value in obj.items()}
    else:
        return obj

def print_node_detailed_info(node, node_id):
    """Print detailed information about a node including exits and boundaries"""
    print(f"\nüîç === DETAILED NODE INFO: {node_id} ===")
    print(f"   üìç Position: {node.position}")
    print(f"   üß± Walls: {node.walls}")
    print(f"   ‚úÖ Visited: {node.visited}")
    print(f"   üî¢ Visit Count: {node.visitCount}")
    print(f"   ‚ö∞Ô∏è Is Dead End: {node.isDeadEnd}")
    print(f"   üîç Fully Scanned: {getattr(node, 'fullyScanned', False)}")
    print(f"   ‚è∞ Last Visited: {node.lastVisited}")
    print(f"   ü§ù Neighbors: {[(dir, neighbor.position if neighbor else None) for dir, neighbor in node.neighbors.items()]}")
    print(f"   ‚ùì Unexplored Exits: {node.unexploredExits}")
    print(f"   üß≠ Explored Directions: {node.exploredDirections}")
    print(f"   üöß Out of Bounds Exits: {node.outOfBoundsExits}")
    print(f"   üìä Out of Bounds Count: {node.outOfBoundsCount}")
    
    # Check for marker-related attributes
    if hasattr(node, 'markersFound'):
        print(f"   üéØ Markers Found: {node.markersFound}")
    if hasattr(node, 'markerScanResults'):
        print(f"   üîç Marker Scan Results: {node.markerScanResults}")
    if hasattr(node, 'hasMarkers'):
        print(f"   üìç Has Markers: {node.hasMarkers}")

def export_maze_data_to_json(graph_mapper, filename):
    """
    Export maze data (robot path and walls) to JSON file for visualization
    """
    try:
        print(f"\nüì§ === STARTING MAZE DATA EXPORT ===")
        
        # Get all positions and find boundaries
        positions = [node.position for node in graph_mapper.nodes.values()]
        if not positions:
            print("‚ùå No maze data to export")
            return
        
        min_x = min(pos[0] for pos in positions)
        max_x = max(pos[0] for pos in positions)
        min_y = min(pos[1] for pos in positions)
        max_y = max(pos[1] for pos in positions)
        
        print(f"üó∫Ô∏è Map boundaries: X[{min_x}, {max_x}], Y[{min_y}, {max_y}]")
        print(f"üìä Total nodes to export: {len(graph_mapper.nodes)}")
        
        # Print detailed info for each node
        for node_id, node in graph_mapper.nodes.items():
            print_node_detailed_info(node, node_id)
        
        # Create maze data structure
        maze_data = {
            "metadata": {
                "export_timestamp": datetime.now().isoformat(),
                "total_nodes_explored": len(graph_mapper.nodes),
                "boundaries": {
                    "min_x": int(min_x),
                    "max_x": int(max_x),
                    "min_y": int(min_y),
                    "max_y": int(max_y),
                    "width": int(max_x - min_x + 1),
                    "height": int(max_y - min_y + 1)
                },
                "robot_start_position": [0, 0],
                "wall_threshold_cm": getattr(graph_mapper, 'WALL_THRESHOLD', 25)
            },
            "nodes": {},
            "robot_path": [],
            "walls": {},
            "grid_representation": {},
            "node_analysis": {},
            "markers": {}  # Enhanced for marker data
        }
        
        print(f"\nüìã === EXPORTING NODE DATA ===")
        
        # Export node data with proper type conversion
        for node_id, node in graph_mapper.nodes.items():
            print(f"üîÑ Processing node: {node_id}")
            
            # Convert all data to JSON-serializable types
            node_data = {
                "position": list(node.position),
                "walls": convert_to_json_serializable(node.walls),
                "visited": convert_to_json_serializable(node.visited),
                "visit_count": convert_to_json_serializable(node.visitCount),
                "is_dead_end": convert_to_json_serializable(node.isDeadEnd),
                "fully_scanned": convert_to_json_serializable(getattr(node, 'fullyScanned', False)),
                "last_visited": str(node.lastVisited),
                "neighbors": {},
                "unexplored_exits": convert_to_json_serializable(node.unexploredExits),
                "explored_directions": convert_to_json_serializable(node.exploredDirections),
                "out_of_bounds_exits": convert_to_json_serializable(node.outOfBoundsExits),
                "out_of_bounds_count": convert_to_json_serializable(node.outOfBoundsCount)
            }
            
            # Add marker-related data if available
            if hasattr(node, 'markersFound'):
                node_data["markers_found"] = convert_to_json_serializable(node.markersFound)
            if hasattr(node, 'markerScanResults'):
                node_data["marker_scan_results"] = convert_to_json_serializable(node.markerScanResults)
            if hasattr(node, 'hasMarkers'):
                node_data["has_markers"] = convert_to_json_serializable(node.hasMarkers)
            
            # Handle neighbors carefully
            for direction, neighbor in node.neighbors.items():
                if neighbor:
                    node_data["neighbors"][direction] = list(neighbor.position)
                else:
                    node_data["neighbors"][direction] = None
            
            maze_data["nodes"][node_id] = node_data
            
            # Add detailed analysis
            maze_data["node_analysis"][node_id] = {
                "total_possible_exits": 4,
                "walls_count": sum(1 for wall in node.walls.values() if wall),
                "available_exits": 4 - sum(1 for wall in node.walls.values() if wall),
                "out_of_bounds_blocked": len(node.outOfBoundsExits),
                "can_explore_count": len(node.unexploredExits),
                "movement_efficiency": f"{node.visitCount} visits"
            }
            
            # Add marker analysis if available
            if hasattr(node, 'markersFound'):
                maze_data["node_analysis"][node_id]["markers_found_count"] = len(node.markersFound)
        
        # Create robot path from visited nodes (chronological order)
        print(f"\nüõ§Ô∏è === CREATING ROBOT PATH ===")
        visited_positions = [[0, 0]]  # Start position
        
        # Sort nodes by visit time if possible, otherwise by position
        sorted_nodes = sorted(graph_mapper.nodes.values(), 
                            key=lambda n: (n.lastVisited, n.position))
        
        for node in sorted_nodes:
            if node.position != (0, 0):
                visited_positions.append(list(node.position))
        
        maze_data["robot_path"] = visited_positions
        print(f"   üìç Path length: {len(visited_positions)} positions")
        
        # Create wall data for easier plotting
        print(f"\nüß± === PROCESSING WALLS ===")
        wall_count = 0
        for node in graph_mapper.nodes.values():
            x, y = node.position
            for direction, has_wall in node.walls.items():
                has_wall = convert_to_json_serializable(has_wall)
                if has_wall:
                    wall_key = f"{x},{y},{direction}"
                    maze_data["walls"][wall_key] = {
                        "position": [int(x), int(y)],
                        "direction": str(direction),
                        "wall_type": "detected"
                    }
                    wall_count += 1
        
        print(f"   üß± Total walls processed: {wall_count}")
        
        # Create grid representation for easy plotting
        print(f"\nüéØ === CREATING GRID REPRESENTATION ===")
        for y in range(min_y, max_y + 1):
            for x in range(min_x, max_x + 1):
                node_id = f"{x},{y}"
                if node_id in graph_mapper.nodes:
                    node = graph_mapper.nodes[node_id]
                    grid_data = {
                        "explored": True,
                        "walls": convert_to_json_serializable(node.walls),
                        "visit_count": convert_to_json_serializable(node.visitCount),
                        "is_dead_end": convert_to_json_serializable(node.isDeadEnd)
                    }
                    
                    # Add marker data to grid if available
                    if hasattr(node, 'hasMarkers'):
                        grid_data["has_markers"] = convert_to_json_serializable(node.hasMarkers)
                    
                    maze_data["grid_representation"][f"{x},{y}"] = grid_data
                else:
                    maze_data["grid_representation"][f"{x},{y}"] = {
                        "explored": False,
                        "walls": {"north": True, "south": True, "east": True, "west": True},
                        "visit_count": 0,
                        "is_dead_end": False,
                        "has_markers": False
                    }
        
        # Compile marker data summary
        print(f"\nüéØ === PROCESSING MARKER DATA ===")
        total_markers_found = 0
        marker_summary = {}
        
        for node_id, node in graph_mapper.nodes.items():
            if hasattr(node, 'markersFound') and node.markersFound:
                marker_summary[node_id] = {
                    "position": list(node.position),
                    "markers": convert_to_json_serializable(node.markersFound),
                    "scan_results": convert_to_json_serializable(getattr(node, 'markerScanResults', {}))
                }
                total_markers_found += len(node.markersFound)
        
        maze_data["markers"] = {
            "total_found": total_markers_found,
            "nodes_with_markers": len(marker_summary),
            "marker_details": marker_summary
        }
        
        print(f"   üéØ Total markers found: {total_markers_found}")
        print(f"   üìç Nodes with markers: {len(marker_summary)}")
        
        # Write to JSON file
        print(f"\nüíæ === WRITING TO JSON FILE ===")
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(maze_data, f, indent=2, ensure_ascii=False)
        
        print(f"\n‚úÖ === EXPORT COMPLETED SUCCESSFULLY ===")
        print(f"üìÅ Maze data exported successfully to: {filename}")
        print(f"   üìä Nodes exported: {len(maze_data['nodes'])}")
        print(f"   üó∫Ô∏è Grid size: {maze_data['metadata']['boundaries']['width']}x{maze_data['metadata']['boundaries']['height']}")
        print(f"   üß± Walls detected: {len(maze_data['walls'])}")
        print(f"   üõ§Ô∏è Path length: {len(maze_data['robot_path'])} positions")
        print(f"   üéØ Markers found: {total_markers_found}")
        
        # Summary statistics
        print(f"\nüìà === EXPORT STATISTICS ===")
        total_out_of_bounds = sum(len(node.outOfBoundsExits) for node in graph_mapper.nodes.values())
        total_unexplored = sum(len(node.unexploredExits) for node in graph_mapper.nodes.values())
        total_walls = sum(sum(1 for wall in node.walls.values() if wall) for node in graph_mapper.nodes.values())
        
        print(f"   üöß Total out-of-bounds exits blocked: {total_out_of_bounds}")
        print(f"   ‚ùì Total unexplored exits remaining: {total_unexplored}")
        print(f"   üß± Total walls detected: {total_walls}")
        print(f"   üéØ Total markers detected: {total_markers_found}")
        print(f"   üèÅ Export file size: {os.path.getsize(filename)} bytes")
        
    except Exception as e:
        print(f"‚ùå Error exporting maze data: {e}")
        import traceback
        traceback.print_exc()


# 4. ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ boundary ‡πÉ‡∏ô main
if __name__ == '__main__':
    print("ü§ñ Connecting to robot...")
    ep_robot = robot.Robot()
    ep_robot.initialize(conn_type="ap")
    
    ep_gimbal = ep_robot.gimbal
    ep_chassis = ep_robot.chassis
    ep_sensor = ep_robot.sensor
    ep_vision = ep_robot.vision
    
    # Initialize components with STRICTER boundaries
    tof_handler = ToFSensorHandler()
    graph_mapper = GraphMapper(min_x=-2, min_y=0, max_x=4, max_y=6)  # 3x3 grid
    movement_controller = MovementController(ep_chassis)
    attitude_handler = AttitudeHandler()
    attitude_handler.start_monitoring(ep_chassis)
    
    # NEW: Initialize marker detection system
    marker_handler = MarkerVisionHandler()
    print("üéØ Initializing marker detection system...")
    marker_detection_active = marker_handler.start_continuous_detection(ep_vision)
    if marker_detection_active:
        print("‚úÖ Marker detection system activated")
    else:
        print("‚ö†Ô∏è Marker detection system failed to activate - continuing without markers")
        marker_handler = None
    
    # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• boundary
    boundary_info = graph_mapper.get_boundary_status()
    print(f"üó∫Ô∏è MAP BOUNDARIES CONFIGURED:")
    print(f"   üìè X range: [{boundary_info['min_x']}, {boundary_info['max_x']}]")
    print(f"   üìè Y range: [{boundary_info['min_y']}, {boundary_info['max_y']}]")
    print(f"   üìê Map size: {boundary_info['width']}x{boundary_info['height']} = {boundary_info['total_cells']} cells")
    print(f"   üéØ Valid positions: Only within these boundaries!")
    
    try:
        print("‚úÖ Recalibrating gimbal...")
        ep_gimbal.recenter(pitch_speed=100, yaw_speed=100).wait_for_completed()
        ep_gimbal.moveto(pitch=0, yaw=0, pitch_speed=50, yaw_speed=50).wait_for_completed()
        time.sleep(0.3)
        
        print(f"üéØ Wall Detection Threshold: {tof_handler.WALL_THRESHOLD}cm")
        
        # Start autonomous exploration with absolute directions
        explore_autonomously_with_absolute_directions(ep_gimbal, ep_chassis, ep_sensor, tof_handler, 
                        graph_mapper, movement_controller, attitude_handler, marker_handler, ep_robot, max_nodes=49)
        
        # Export maze data to JSON file
        export_maze_data_to_json(graph_mapper, "maze_data.json")
            
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è Interrupted by user")
        export_maze_data_to_json(graph_mapper, "maze_data.json")
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
    finally:
        try:
            ep_sensor.unsub_distance()
            if marker_handler:
                marker_handler.stop_continuous_detection(ep_vision)
            movement_controller.cleanup()
            attitude_handler.stop_monitoring(ep_chassis)
        except:
            pass
        ep_robot.close()
        print("üîå Connection closed")


# 4. ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ boundary ‡πÉ‡∏ô main